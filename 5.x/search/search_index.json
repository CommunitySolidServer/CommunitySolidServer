{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the Community Solid Server! Here we will cover many aspects of the server, such as how to propose changes, what the architecture looks like, and how to use many of the features the server provides.</p> <p>The documentation here is still incomplete both in content and structure, so feel free to open a discussion about things you want to see added. While we try to update this documentation together with updates in the code, it is always possible we miss something, so please report it if you find incorrect information or links that no longer work.</p> <p>An introductory tutorial that gives a quick overview of the Solid and CSS basics can be found here. This is a good way to get started with the server and its setup.</p> <p>If you want to know what is new in the latest version, you can check out the release notes for a high level overview and information on how to migrate your configuration to the next version. A list that includes all minor changes can be found in the changelog</p>"},{"location":"#using-the-server","title":"Using the server","text":"<ul> <li>Basic example HTTP requests</li> <li>Editing the metadata of a resource</li> <li>How to use the Identity Provider</li> <li>How to automate authentication</li> <li>How to automatically seed pods on startup</li> <li>Using the CSS as a development server in another project</li> </ul>"},{"location":"#what-the-internals-look-like","title":"What the internals look like","text":"<ul> <li>How the server uses dependency injection</li> <li>What the architecture looks like</li> </ul>"},{"location":"#comprehensive-guides-and-tutorials","title":"Comprehensive guides and tutorials","text":"<ul> <li>The CSS tutorial repository</li> <li>CSS configuration generator</li> </ul>"},{"location":"#making-changes","title":"Making changes","text":"<ul> <li>How to make changes to the repository</li> </ul> <p>For core developers with push access only:</p> <ul> <li>How to release a new version</li> </ul>"},{"location":"architecture/core/","title":"Core building blocks","text":"<p>There are several core building blocks used in many places of the server. These are described here.</p>"},{"location":"architecture/core/#handlers","title":"Handlers","text":"<p>A very important building block that gets reused in many places is the <code>AsyncHandler</code>. The idea is that a handler has 2 important functions. <code>canHandle</code> determines if this class is capable of correctly handling the request, and throws an error if it can not. For example, a class that converts JSON-LD to turtle can handle all requests containing JSON-LD data, but does not know what to do with a request that contains a JPEG. The second function is <code>handle</code> where the class executes on the input data and returns the result. If an error gets thrown here it means there is an issue with the input. For example, if the input data claims to be JSON-LD but is actually not.</p> <p>The power of using this interface really shines when using certain utility classes. The one we use the most is the <code>WaterfallHandler</code>, which takes as input a list of handlers of the same type. The input and output of a <code>WaterfallHandler</code> is the same as those of its inputs, meaning it can be used in the same places. When doing a <code>canHandle</code> call, it will iterate over all its input handlers to find the first one where the <code>canHandle</code> call succeeds, and when calling <code>handle</code> it will return the result of that specific handler. This allows us to chain together many handlers that each have their specific niche, such as handler that each support a specific HTTP method (GET/PUT/POST/etc.), or handlers that only take requests targeting a specific subset of URLs. To the parent class it will look like it has a handler that supports all methods, while in practice it will be a <code>WaterfallHandler</code> containing all these separate handlers.</p> <p>Some other utility classes are the <code>ParallelHandler</code> that runs all handlers simultaneously, and the <code>SequenceHandler</code> that runs all of them one after the other. Since multiple handlers are executed here, these only work for handlers that have no output.</p>"},{"location":"architecture/core/#streams","title":"Streams","text":"<p>Almost all data is handled in a streaming fashion. This allows us to work with very large resources without having to fully load them in memory, a client could be reading data that is being returned by the server while the server is still reading the file. Internally this means we are mostly handling data as <code>Readable</code> objects. We actually use <code>Guarded&lt;Readable&gt;</code> which is an internal format we created to help us with error handling. Such streams can be created using utility functions such as <code>guardStream</code> and <code>guardedStreamFrom</code>. Similarly, we have a <code>pipeSafely</code> to pipe streams in such a way that also helps with errors.</p>"},{"location":"architecture/dependency-injection/","title":"Dependency injection","text":"<p>The community server uses the dependency injection framework Components.js to link all class instances together, and uses Components-Generator.js to automatically generate the necessary description configurations of all classes. This framework allows us to configure our components in a JSON file. The advantage of this is that changing the configuration of components does not require any changes to the code, as one can just change the default configuration file, or provide a custom configuration file.</p> <p>More information can be found in the Components.js documentation, but a summarized overview can be found below.</p>"},{"location":"architecture/dependency-injection/#component-files","title":"Component files","text":"<p>Components.js requires a component file for every class you might want to instantiate. Fortunately those get generated automatically by Components-Generator.js. Calling <code>npm run build</code> will call the generator and generate those JSON-LD files in the <code>dist</code> folder. The generator uses the <code>index.ts</code>, so new classes always have to be added there or they will not get a component file.</p>"},{"location":"architecture/dependency-injection/#configuration-files","title":"Configuration files","text":"<p>Configuration files are how we tell Components.js which classes to instantiate and link together. All the community server configurations can be found in the <code>config</code> folder. That folder also contains information about how different pre-defined configurations can be used.</p> <p>A single component in such a configuration file might look as follows:</p> <pre><code>{\n\"comment\": \"Storage used for account management.\",\n\"@id\": \"urn:solid-server:default:AccountStorage\",\n\"@type\": \"JsonResourceStorage\",\n\"source\": { \"@id\": \"urn:solid-server:default:ResourceStore\" },\n\"baseUrl\": { \"@id\": \"urn:solid-server:default:variable:baseUrl\" },\n\"container\": \"/.internal/accounts/\"\n}\n</code></pre> <p>With the corresponding constructor of the <code>JsonResourceStorage</code> class:</p> <pre><code>public constructor(source: ResourceStore, baseUrl: string, container: string)\n</code></pre> <p>The important elements here are the following:</p> <ul> <li><code>\"comment\"</code>: (optional) A description of this component.</li> <li><code>\"@id\"</code>: (optional) A unique identifier of this component, which allows it to be used as parameter values in     different places.</li> <li><code>\"@type\"</code>: The class name of the component. This must be a TypeScript class name that is exported via <code>index.ts</code>.</li> </ul> <p>As you can see from the constructor, the other fields are direct mappings from the constructor parameters. <code>source</code> references another object, which we refer to using its identifier <code>urn:solid-server:default:ResourceStore</code>. <code>baseUrl</code> is just a string, but here we use a variable that was set before calling Components.js which is why it also references an <code>@id</code>. These variables are set when starting up the server, based on the command line parameters.</p>"},{"location":"architecture/overview/","title":"Architecture overview","text":"<p>The initial architecture document the project was started from can be found here. Many things have been added since the original inception of the project, but the core ideas within that document are still valid.</p> <p>As can be seen from the architecture, an important idea is the modularity of all components. No actual implementations are defined there, only their interfaces. Making all the components independent of each other in such a way provides us with an enormous flexibility: they can all be replaced by a different implementation, without impacting anything else. This is how we can provide many different configurations for the server, and why it is impossible to provide ready solutions for all possible combinations.</p>"},{"location":"architecture/overview/#architecture-diagrams","title":"Architecture diagrams","text":"<p>Having a modular architecture makes it more difficult to give a complete architecture overview. We will limit ourselves to the more commonly used default configurations we provide, and in certain cases we might give examples of what differences there are based on what configurations are being imported.</p> <p>To do this we will make use of architecture diagrams. We will use an example below to explain the formatting used throughout the architecture documentation:</p> <pre><code>flowchart TD\n  LdpHandler(\"&lt;strong&gt;LdpHandler&lt;/strong&gt;&lt;br&gt;ParsingHttphandler\")\n  LdpHandler --&gt; LdpHandlerArgs\n\n  subgraph LdpHandlerArgs[\" \"]\n    RequestParser(\"&lt;strong&gt;RequestParser&lt;/strong&gt;&lt;br&gt;BasicRequestParser\")\n    Auth(\"&lt;br&gt;AuthorizingHttpHandler\")\n    ErrorHandler(\"&lt;strong&gt;ErrorHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ErrorHandler&lt;/&gt;\")\n    ResponseWriter(\"&lt;strong&gt;ResponseWriter&lt;/strong&gt;&lt;br&gt;BasicResponseWriter\")\n  end</code></pre> <p>Below is a summary of how to interpret such diagrams:</p> <ul> <li>Rounded red box: component instantiated in the Components.js configuration.<ul> <li>First line:<ul> <li>Bold text: shorthand of the instance identifier. In case the full URI is not specified,     it can usually be found by prepending <code>urn:solid-server:default:</code> to the shorthand identifier.</li> <li>(empty): this instance has no identifier and is defined in the same place as its parent.</li> </ul> </li> <li>Second line:<ul> <li>Regular text: The class of this instance.</li> <li>Italic text: The interface of this instance.     Will be used if the actual class is not relevant for the explanation or can differ.</li> </ul> </li> </ul> </li> <li>Square grey box: the parameters of the linked instance.</li> <li>Arrow: links an instance to its parameters. Can also be used to indicate the order of parameters if relevant.</li> </ul> <p>For example, in the above, LdpHandler is a shorthand for the actual identifier <code>urn:solid-server:default:LdpHandler</code> and is an instance of <code>ParsingHttpHandler</code>. It has 4 parameters, one of which has no identifier but is an instance of <code>AuthorizingHttpHandler</code>.</p>"},{"location":"architecture/overview/#features","title":"Features","text":"<p>Below are the sections that go deeper into the features of the server and how those work.</p> <ul> <li>How Command Line Arguments are parsed and used</li> <li>How the server is initialized and started</li> <li>How HTTP requests are handled</li> <li>How the server handles a standard Solid request</li> </ul>"},{"location":"architecture/features/cli/","title":"Parsing Command line arguments","text":"<p>When starting the server, the application actually uses Components.js twice to instantiate components. The first instantiation is used to parse the command line arguments. These then get converted into Components.js variables and are used to instantiate the actual server.</p>"},{"location":"architecture/features/cli/#architecture","title":"Architecture","text":"<pre><code>flowchart TD\n  CliResolver(\"&lt;strong&gt;CliResolver&lt;/strong&gt;&lt;br&gt;CliResolver\")\n  CliResolver --&gt; CliResolverArgs\n\n  subgraph CliResolverArgs[\" \"]\n    CliExtractor(\"&lt;strong&gt;CliExtractor&lt;/strong&gt;&lt;br&gt;YargsCliExtractor\")\n    ShorthandResolver(\"&lt;strong&gt;ShorthandResolver&lt;/strong&gt;&lt;br&gt;CombinedShorthandResolver\")\n  end\n\n  ShorthandResolver --&gt; ShorthandResolverArgs\n  subgraph ShorthandResolverArgs[\" \"]\n    BaseUrlExtractor(\"&lt;br&gt;BaseUrlExtractor\")\n    KeyExtractor(\"&lt;br&gt;KeyExtractor\")\n    AssetPathExtractor(\"&lt;br&gt;AssetPathExtractor\")\n  end</code></pre> <p>The <code>CliResolver</code> (<code>urn:solid-server-app-setup:default:CliResolver</code>) is simply a way to combine both the <code>CliExtractor</code> (<code>urn:solid-server-app-setup:default:CliExtractor</code>) and <code>ShorthandResolver</code> (<code>urn:solid-server-app-setup:default:ShorthandResolver</code>) into a single object and has no other function.</p> <p>Which arguments are supported and which Components.js variables are generated can depend on the configuration that is being used. For example, for an HTTPS server additional arguments will be needed to specify the necessary key/cert files.</p>"},{"location":"architecture/features/cli/#cliresolver","title":"CliResolver","text":"<p>The <code>CliResolver</code> converts the incoming string of arguments into a key/value object. By default, a <code>YargsCliExtractor</code> is used, which makes use of the <code>yargs</code> library and is configured similarly.</p>"},{"location":"architecture/features/cli/#shorthandresolver","title":"ShorthandResolver","text":"<p>The <code>ShorthandResolver</code> uses the key/value object that was generated above to generate Components.js variable bindings. A <code>CombinedShorthandResolver</code> combines the results of multiple <code>ShorthandExtractor</code> by mapping their values to specific variables. For example, a <code>BaseUrlExtractor</code> will be used to extract the value for <code>baseUrl</code>, or <code>port</code> if no <code>baseUrl</code> value is provided, and use it to generate the value for the variable <code>urn:solid-server:default:variable:baseUrl</code>.</p> <p>These extractors are also where the default values for the server are defined. For example, BaseUrlExtractor will be instantiated with a default port of <code>3000</code> which will be used if no port is provided.</p> <p>The variables generated here will be used to initialize the server.</p>"},{"location":"architecture/features/http-handler/","title":"Handling HTTP requests","text":"<p>The direction of the arrows was changed slightly here to make the graph readable.</p> <pre><code>flowchart LR\n  HttpHandler(\"&lt;strong&gt;HttpHandler&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n  HttpHandler --&gt; HttpHandlerArgs\n\n  subgraph HttpHandlerArgs[\" \"]\n    direction LR\n    Middleware(\"&lt;strong&gt;Middleware&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    WaterfallHandler(\"&lt;br&gt;WaterfallHandler\")\n  end\n\n  Middleware --&gt; WaterfallHandler\n  WaterfallHandler --&gt; WaterfallHandlerArgs\n\n  subgraph WaterfallHandlerArgs[\" \"]\n    direction TB\n    StaticAssetHandler(\"&lt;strong&gt;StaticAssetHandler&lt;/strong&gt;&lt;br&gt;StaticAssetHandler\")\n    SetupHandler(\"&lt;strong&gt;SetupHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    OidcHandler(\"&lt;strong&gt;OidcHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    AuthResourceHttpHandler(\"&lt;strong&gt;AuthResourceHttpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    IdentityProviderHttpHandler(\"&lt;strong&gt;IdentityProviderHttpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    LdpHandler(\"&lt;strong&gt;LdpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n  end\n\n  StaticAssetHandler --&gt; SetupHandler\n  SetupHandler --&gt; OidcHandler\n  OidcHandler --&gt; AuthResourceHttpHandler\n  AuthResourceHttpHandler --&gt; IdentityProviderHttpHandler\n  IdentityProviderHttpHandler --&gt; LdpHandler</code></pre> <p>The <code>HttpHandler</code> is responsible for handling an incoming HTTP request. The request will always first go through the <code>Middleware</code>, where certain required headers will be added such as CORS headers.</p> <p>After that it will go through the list in the <code>WaterfallHandler</code> to find the first handler that understands the request, with the <code>LdpHandler</code> at the bottom being the catch-all default.</p>"},{"location":"architecture/features/http-handler/#staticassethandler","title":"StaticAssetHandler","text":"<p>The <code>urn:solid-server:default:StaticAssetHandler</code> matches exact URLs to static assets which require no further logic. An example of this is the favicon, where the <code>/favicon.ico</code> URL is directed to the favicon file at <code>/templates/images/favicon.ico</code>. It can also map entire folders to a specific path, such as <code>/.well-known/css/styles/</code> which contains all stylesheets.</p>"},{"location":"architecture/features/http-handler/#setuphandler","title":"SetupHandler","text":"<p>The <code>urn:solid-server:default:SetupHandler</code> is responsible for redirecting all requests to <code>/setup</code> until setup is finished, thereby ensuring that setup needs to be finished before anything else can be done on the server, and handling the actual setup request that is sent to <code>/setup</code>. Once setup is finished, this handler will reject all requests and thus no longer be relevant.</p> <p>If the server is configured to not have setup enabled, the corresponding identifier will point to a handler that always rejects all requests.</p>"},{"location":"architecture/features/http-handler/#oidchandler","title":"OidcHandler","text":"<p>The <code>urn:solid-server:default:OidcHandler</code> handles all requests related to the Solid-OIDC specification. The OIDC component is configured to work on the <code>/.oidc/</code> subpath, so this handler catches all those requests and sends them to the internal OIDC library that is used.</p>"},{"location":"architecture/features/http-handler/#authresourcehttphandler","title":"AuthResourceHttpHandler","text":"<p>The <code>urn:solid-server:default:AuthResourceHttpHandler</code> is identical to the <code>urn:solid-server:default:LdpHandler</code> which will be discussed below, but only handles resources relevant for authorization.</p> <p>In practice this means that is your server is configured to use Web Access Control for authorization, this handler will catch all requests targeting <code>.acl</code> resources.</p> <p>The reason these already need to be handled here is so these can also be used to allow authorization on the following handler(s). More on this can be found in the identity provider documentation</p>"},{"location":"architecture/features/http-handler/#identityproviderhttphandler","title":"IdentityProviderHttpHandler","text":"<p>The <code>urn:solid-server:default:IdentityProviderHttpHandler</code> handles everything related to our custom identity provider API, such as registering, logging in, returning the relevant HTML pages, etc. All these requests are identified by being on the <code>/idp/</code> subpath. More information on the API can be found in the identity provider documentation</p>"},{"location":"architecture/features/http-handler/#ldphandler","title":"LdpHandler","text":"<p>Once a request reaches the <code>urn:solid-server:default:LdpHandler</code>, the server assumes this is a standard Solid request according to the Solid protocol. A detailed description of what happens then can be found here</p>"},{"location":"architecture/features/initialization/","title":"Server initialization","text":"<p>When starting the server, multiple Initializers trigger to set up everything correctly, the last one of which starts listening to the specified port. Similarly, when stopping the server several Finalizers trigger to clean up where necessary, although the latter only happens when starting the server through code.</p>"},{"location":"architecture/features/initialization/#app","title":"App","text":"<pre><code>flowchart TD\n  App(\"&lt;strong&gt;App&lt;/strong&gt;&lt;br&gt;App\")\n  App --&gt; AppArgs\n\n  subgraph AppArgs[\" \"]\n    Initializer(\"&lt;strong&gt;Initializer&lt;/strong&gt;&lt;br&gt;&lt;i&gt;Initializer&lt;/i&gt;\")\n    AppFinalizer(\"&lt;strong&gt;Finalizer&lt;/strong&gt;&lt;br&gt;&lt;i&gt;Finalizer&lt;/i&gt;\")\n  end</code></pre> <p><code>App</code> (<code>urn:solid-server:default:App</code>) is the main component that gets instantiated by Components.js. Every other component should be able to trace an instantiation path back to it if it also wants to be instantiated.</p> <p>It's only function is to contain an <code>Initializer</code> and <code>Finalizer</code> which get called by calling <code>start</code>/<code>stop</code> respectively.</p>"},{"location":"architecture/features/initialization/#initializer","title":"Initializer","text":"<pre><code>flowchart TD\n  Initializer(\"&lt;strong&gt;Initializer&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n  Initializer --&gt; InitializerArgs\n\n  subgraph InitializerArgs[\" \"]\n    direction LR\n    LoggerInitializer(\"&lt;strong&gt;LoggerInitializer&lt;/strong&gt;&lt;br&gt;LoggerInitializer\")\n    PrimaryInitializer(\"&lt;strong&gt;PrimaryInitializer&lt;/strong&gt;&lt;br&gt;ProcessHandler\")\n    WorkerInitializer(\"&lt;strong&gt;WorkerInitializer&lt;/strong&gt;&lt;br&gt;ProcessHandler\")\n  end\n\n  LoggerInitializer --&gt; PrimaryInitializer\n  PrimaryInitializer --&gt; WorkerInitializer</code></pre> <p>The very first thing that needs to happen is initializing the logger. Before this other classes will be unable to use logging.</p> <p>The <code>PrimaryInitializer</code> will only trigger once, in the primary worker thread, while the <code>WorkerInitializer</code> will trigger for every worker thread. Although if your server setup is single-threaded, which is the default, there is no relevant difference between those two.</p>"},{"location":"architecture/features/initialization/#primaryinitializer","title":"PrimaryInitializer","text":"<pre><code>flowchart TD\n  PrimaryInitializer(\"&lt;strong&gt;PrimaryInitializer&lt;/strong&gt;&lt;br&gt;ProcessHandler\")\n  PrimaryInitializer --&gt; PrimarySequenceInitializer(\"&lt;strong&gt;PrimarySequenceInitializer&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n  PrimarySequenceInitializer --&gt; PrimarySequenceInitializerArgs\n\n  subgraph PrimarySequenceInitializerArgs[\" \"]\n    direction LR\n    CleanupInitializer(\"&lt;strong&gt;CleanupInitializer&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n    PrimaryParallelInitializer(\"&lt;strong&gt;PrimaryParallelInitializer&lt;/strong&gt;&lt;br&gt;ParallelHandler\")\n    WorkerManager(\"&lt;strong&gt;WorkerManager&lt;/strong&gt;&lt;br&gt;WorkerManager\")\n  end\n\n  CleanupInitializer --&gt; PrimaryParallelInitializer\n  PrimaryParallelInitializer --&gt; WorkerManager</code></pre> <p>The above is a simplification of all the initializers that are present in the <code>PrimaryInitializer</code> as there are several smaller initializers that also trigger but are less relevant here.</p> <p>The <code>CleanupInitializer</code> is an initializer that cleans up anything that might have remained from a previous server start and could impact behaviour. Relevant components in other parts of the configuration are responsible for adding themselves to this array if needed. An example of this is file-based locking components which might need to remove any dangling locking files.</p> <p>The <code>PrimaryParallelInitializer</code> can be used to add any initializers to that have to happen in the primary process. This makes it easier for users to add initializers by being able to append to its handlers.</p> <p>The <code>WorkerManager</code> is responsible for setting up the worker threads, if any.</p>"},{"location":"architecture/features/initialization/#workerinitializer","title":"WorkerInitializer","text":"<pre><code>flowchart TD\n  WorkerInitializer(\"&lt;strong&gt;WorkerInitializer&lt;/strong&gt;&lt;br&gt;ProcessHandler\")\n  WorkerInitializer --&gt; WorkerSequenceInitializer(\"&lt;strong&gt;WorkerSequenceInitializer&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n  WorkerSequenceInitializer --&gt; WorkerSequenceInitializerArgs\n\n  subgraph WorkerSequenceInitializerArgs[\" \"]\n    direction LR\n    WorkerParallelInitializer(\"&lt;strong&gt;WorkerParallelInitializer&lt;/strong&gt;&lt;br&gt;ParallelHandler\")\n    ServerInitializer(\"&lt;strong&gt;ServerInitializer&lt;/strong&gt;&lt;br&gt;ServerInitializer\")\n  end\n\n  WorkerParallelInitializer --&gt; ServerInitializer</code></pre> <p>The <code>WorkerInitializer</code> is quite similar to the <code>PrimaryInitializer</code> but triggers once per worker thread. Like the <code>PrimaryParallelInitializer</code>, the <code>WorkerParallelInitializer</code> can be used to add any custom initializers that need to run.</p>"},{"location":"architecture/features/initialization/#serverinitializer","title":"ServerInitializer","text":"<p>The <code>ServerInitializer</code> is the initializer that finally starts up the server by listening to the relevant port, once all the initialization described above is finished. This is an example of a component that differs based on some of the choices made during configuration.</p> <pre><code>flowchart TD\n  ServerInitializer(\"&lt;strong&gt;ServerInitializer&lt;/strong&gt;&lt;br&gt;ServerInitializer\")\n  ServerInitializer --&gt; WebSocketServerFactory(\"&lt;strong&gt;ServerFactory&lt;/strong&gt;&lt;br&gt;WebSocketServerFactory\")\n  WebSocketServerFactory --&gt; BaseHttpServerFactory(\"&lt;br&gt;BaseHttpServerFactory\")\n  BaseHttpServerFactory --&gt; HttpHandler(\"&lt;strong&gt;HttpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n\n  ServerInitializer2(\"&lt;strong&gt;ServerInitializer&lt;/strong&gt;&lt;br&gt;ServerInitializer\")\n  ServerInitializer2 ---&gt; BaseHttpServerFactory2(\"&lt;strong&gt;ServerFactory&lt;/strong&gt;&lt;br&gt;BaseHttpServerFactory\")\n  BaseHttpServerFactory2 --&gt; HttpHandler2(\"&lt;strong&gt;HttpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")</code></pre> <p>Depending on if the configurations necessary for websockets are imported or not, the <code>urn:solid-server:default:ServerFactory</code> identifier will point to a different resource. There will always be a <code>BaseHttpServerFactory</code> that starts the HTTP(S) server, but there might also be a <code>WebSocketServerFactory</code> wrapped around it to handle websocket support. Although not indicated here, the parameters for initializing the <code>BaseHttpServerFactory</code> might also differ in case an HTTPS configuration is imported.</p> <p>The <code>HttpHandler</code> it takes as input is responsible for how HTTP requests get resolved.</p>"},{"location":"architecture/features/protocol/authorization/","title":"Authorization","text":"<pre><code>flowchart TD\n  AuthorizingHttpHandler(\"&lt;br&gt;AuthorizingHttpHandler\")\n  AuthorizingHttpHandler --&gt; AuthorizingHttpHandlerArgs\n\n  subgraph AuthorizingHttpHandlerArgs[\" \"]\n    CredentialsExtractor(\"&lt;strong&gt;CredentialsExtractor&lt;/strong&gt;&lt;br&gt;&lt;i&gt;CredentialsExtractor&lt;/i&gt;\")\n    ModesExtractor(\"&lt;strong&gt;ModesExtractor&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ModesExtractor&lt;/i&gt;\")\n    PermissionReader(\"&lt;strong&gt;PermissionReader&lt;/strong&gt;&lt;br&gt;&lt;i&gt;PermissionReader&lt;/i&gt;\")\n    Authorizer(\"&lt;strong&gt;Authorizer&lt;/strong&gt;&lt;br&gt;PermissionBasedAuthorizer\")\n    OperationHttpHandler(\"&lt;br&gt;&lt;i&gt;OperationHttpHandler&lt;/i&gt;\")\n  end</code></pre> <p>Authorization is usually handled by the <code>AuthorizingHttpHandler</code>, which receives a parsed HTTP request in the form of an <code>Operation</code>. It goes through the following steps:</p> <ol> <li>A <code>CredentialsExtractor</code> identifies the credentials of the agent making the call.</li> <li>A <code>ModesExtractor</code> finds which access modes are needed for which resources.</li> <li>A <code>PermissionReader</code> determines the permissions the agent has on the targeted resources.</li> <li>The above results are compared in an <code>Authorizer</code>.</li> <li>If the request is allowed, call the <code>OperationHttpHandler</code>, otherwise throw an error.</li> </ol>"},{"location":"architecture/features/protocol/authorization/#authentication","title":"Authentication","text":"<p>There are multiple <code>CredentialsExtractor</code>s that each determine identity in a different way. Potentially multiple extractors can apply, making a requesting agent have multiple credentials.</p> <p>The diagram below shows the default configuration if authentication is enabled.</p> <pre><code>flowchart TD\n  CredentialsExtractor(\"&lt;strong&gt;CredentialsExtractor&lt;/strong&gt;&lt;br&gt;UnionCredentialsExtractor\")\n  CredentialsExtractor --&gt; CredentialsExtractorArgs\n\n  subgraph CredentialsExtractorArgs[\" \"]\n    WaterfallHandler(\"&lt;br&gt;WaterfallHandler\")\n    PublicCredentialsExtractor(\"&lt;br&gt;PublicCredentialsExtractor\")\n  end\n\n  WaterfallHandler --&gt; WaterfallHandlerArgs\n  subgraph WaterfallHandlerArgs[\" \"]\n    direction LR\n    DPoPWebIdExtractor(\"&lt;br&gt;DPoPWebIdExtractor\") --&gt; BearerWebIdExtractor(\"&lt;br&gt;BearerWebIdExtractor\")\n  end</code></pre> <p>Both of the WebID extractors make use of the <code>access-token-verifier</code> library to parse incoming tokens based on the Solid-OIDC specification. Besides those there are always the public credentials, which everyone has. All these credentials then get combined into a single union object.</p> <p>If successful, a <code>CredentialsExtractor</code> will return a key/value map linking the type of credentials to their specific values.</p> <p>There are also debug configuration options available that can be used to simulate credentials. These can be enabled as different options through the <code>config/ldp/authentication</code> imports.</p>"},{"location":"architecture/features/protocol/authorization/#modes-extraction","title":"Modes extraction","text":"<p>Access modes are a predefined list of <code>read</code>, <code>write</code>, <code>append</code>, <code>create</code> and <code>delete</code>. The <code>ModesExtractor</code> determine which modes will be necessary and for which resources, based on the request contents.</p> <pre><code>flowchart TD\n  ModesExtractor(\"&lt;strong&gt;ModesExtractor&lt;/strong&gt;&lt;br&gt;IntermediateCreateExtractor\")\n  ModesExtractor --&gt; HttpModesExtractor(\"&lt;strong&gt;HttpModesExtractor&lt;/strong&gt;&lt;br&gt;WaterfallHandler\")\n\n  HttpModesExtractor --&gt; HttpModesExtractorArgs\n\n  subgraph HttpModesExtractorArgs[\" \"]\n    direction LR\n    PatchModesExtractor(\"&lt;strong&gt;PatchModesExtractor&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ModesExtractor&lt;/i&gt;\") --&gt; MethodModesExtractor(\"&lt;br&gt;MethodModesExtractor\")\n  end</code></pre> <p>The <code>IntermediateCreateExtractor</code> is responsible if requests try to create intermediate containers with a single request. E.g., a PUT request to <code>/foo/bar/baz</code> should create both the <code>/foo/</code> and <code>/foo/bar/</code> containers in case they do not exist yet. This extractor makes sure that <code>create</code> permissions are also checked on those containers.</p> <p>Modes can usually be determined based on just the HTTP methods, which is what the <code>MethodModesExtractor</code> does. A GET request will always need the <code>read</code> mode for example.</p> <p>The only exception are PATCH requests, where the necessary modes depend on the body and the PATCH type.</p> <pre><code>flowchart TD\n  PatchModesExtractor(\"&lt;strong&gt;PatchModesExtractor&lt;/strong&gt;&lt;br&gt;WaterfallHandler\") --&gt; PatchModesExtractorArgs\n  subgraph PatchModesExtractorArgs[\" \"]\n    N3PatchModesExtractor(\"&lt;br&gt;N3PatchModesExtractor\")\n    SparqlUpdateModesExtractor(\"&lt;br&gt;SparqlUpdateModesExtractor\")\n  end</code></pre> <p>The server supports both N3 Patch and SPARQL Update PATCH requests. In both cases it will parse the bodies to determine what the impact would be of the request and what modes it requires.</p>"},{"location":"architecture/features/protocol/authorization/#permission-reading","title":"Permission reading","text":"<p><code>PermissionReaders</code> take the input of the above to determine which permissions are available for which credentials. The modes from the previous step are not yet needed, but can be used as optimization as we only need to know if we have permission on those modes. Each reader returns all the information it can find based on the resources and modes it receives. In the default configuration the following readers are combined when WebACL is enabled as authorization method. In case authorization is disabled by changing the authorization import to <code>config/ldp/authorization/allow-all.json</code>, this diagram is just a class that always returns all permissions.</p> <pre><code>flowchart TD\n  PermissionReader(\"&lt;strong&gt;PermissionReader&lt;/strong&gt;&lt;br&gt;AuxiliaryReader\")\n  PermissionReader --&gt; UnionPermissionReader(\"&lt;br&gt;UnionPermissionReader\")\n  UnionPermissionReader --&gt; UnionPermissionReaderArgs\n\n  subgraph UnionPermissionReaderArgs[\" \"]\n    PathBasedReader(\"&lt;strong&gt;PathBasedReader&lt;/strong&gt;&lt;br&gt;PathBasedReader\")\n    OwnerPermissionReader(\"&lt;strong&gt;OwnerPermissionReader&lt;/strong&gt;&lt;br&gt;OwnerPermissionReader\")\n    WrappedWebAclReader(\"&lt;strong&gt;WrappedWebAclReader&lt;/strong&gt;&lt;br&gt;ParentContainerReader\")\n  end\n\n  WrappedWebAclReader --&gt; WebAclAuxiliaryReader(\"&lt;strong&gt;WebAclAuxiliaryReader&lt;/strong&gt;&lt;br&gt;WebAclAuxiliaryReader\")\n  WebAclAuxiliaryReader --&gt; WebAclReader(\"&lt;strong&gt;WebAclReader&lt;/strong&gt;&lt;br&gt;WebAclReader\")</code></pre> <p>The first thing that happens is that if the target is an auxiliary resource that uses the authorization of its subject resource, the <code>AuxiliaryReader</code> inserts that identifier instead. An example of this is if the requests targets the metadata of a resource.</p> <p>The <code>UnionPermissionReader</code> then combines the results of its readers into a single permission object. If one reader rejects a specific mode and another allows it, the rejection takes priority.</p> <p>The <code>PathBasedReader</code> rejects all permissions for certain paths. This is used to prevent access to the internal data of the server.</p> <p>The <code>OwnerPermissionReader</code> makes sure owners always have control access to the pods they created on the server. Users will always be able to modify the ACL resources in their pod, even if they accidentally removed their own access.</p> <p>The final readers are specifically relevant for the WebACL algorithm. The <code>ParentContainerReader</code> checks the permissions on a parent resource if required: creating a resource requires <code>append</code> permissions on the parent container, while deleting a resource requires <code>write</code> permissions there.</p> <p>In case the target is an ACL resource, <code>control</code> permissions need to be checked, no matter what mode was generated by the <code>ModesExtractor</code>. The <code>WebAclAuxiliaryReader</code> makes sure this conversion happens.</p> <p>Finally, the <code>WebAclReader</code> implements the efffective ACL resource algorithm and returns the permissions it finds in that resource. In case no ACL resource is found this indicates a configuration error and no permissions will be granted.</p>"},{"location":"architecture/features/protocol/authorization/#authorization_1","title":"Authorization","text":"<p>All the results of the previous steps then get combined in the <code>PermissionBasedAuthorizer</code> to either allow or reject a request. If no permissions are found for a requested mode, or they are explicitly forbidden, a 401/403 will be returned, depending on if the agent was logged in or not.</p>"},{"location":"architecture/features/protocol/overview/","title":"Solid protocol","text":"<p>The <code>LdpHandler</code>, named as a reference to the Linked Data Platform specification, chains several handlers together, each with their own specific purpose, to fully resolve the HTTP request. It specifically handles Solid requests as described in the protocol specification, e.g. a POST request to create a new resource.</p> <p>Below is a simplified view of how these handlers are linked.</p> <pre><code>flowchart LR\n  LdpHandler(\"&lt;strong&gt;LdpHandler&lt;/strong&gt;&lt;br&gt;ParsingHttphandler\")\n  LdpHandler --&gt; AuthorizingHttpHandler(\"&lt;br&gt;AuthorizingHttpHandler\")\n  AuthorizingHttpHandler --&gt; OperationHandler(\"&lt;strong&gt;OperationHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;OperationHandler&lt;/i&gt;\")\n  OperationHandler --&gt; ResourceStore(\"&lt;strong&gt;ResourceStore&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ResourceStore&lt;/i&gt;\")</code></pre> <p>A standard request would go through the following steps:</p> <ol> <li>The <code>ParsingHttphandler</code> parses the HTTP request into a manageable format, both body and metadata such as headers.</li> <li>The <code>AuthorizingHttpHandler</code> verifies if the request is authorized to access the targeted resource.</li> <li>The <code>OperationHandler</code> determines which action is required based on the HTTP method.</li> <li>The <code>ResourceStore</code> does all the relevant data work.</li> <li>The <code>ParsingHttphandler</code> eventually receives the response data, or an error, and handles the output.</li> </ol> <p>Below are sections that go deeper into the specific steps.</p> <ul> <li>How input gets parsed and output gets returned</li> <li>How authentication and authorization work</li> <li>What the <code>ResourceStore</code> looks like</li> </ul>"},{"location":"architecture/features/protocol/parsing/","title":"Parsing and responding to HTTP requests","text":"<pre><code>flowchart TD\n  ParsingHttphandler(\"&lt;br&gt;ParsingHttphandler\")\n  ParsingHttphandler --&gt; ParsingHttphandlerArgs\n\n  subgraph ParsingHttphandlerArgs[\" \"]\n    RequestParser(\"&lt;strong&gt;RequestParser&lt;/strong&gt;&lt;br&gt;BasicRequestParser\")\n    AuthorizingHttpHandler(\"&lt;strong&gt;&lt;/strong&gt;&lt;br&gt;AuthorizingHttpHandler\")\n    ErrorHandler(\"&lt;strong&gt;ErrorHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ErrorHandler&lt;/i&gt;\")\n    ResponseWriter(\"&lt;strong&gt;ResponseWriter&lt;/strong&gt;&lt;br&gt;BasicResponseWriter\")\n  end</code></pre> <p>A <code>ParsingHttpHandler</code> handles both the parsing of the input data, and the serializing of the output data. It follows these 3 steps:</p> <ol> <li>Use the <code>RequestParser</code> to convert the incoming data into an <code>Operation</code>.</li> <li>Send the <code>Operation</code> to the <code>AuthorizingHttpHandler</code> to receive either a <code>Representation</code> if the operation was a success,     or an <code>Error</code> in case something went wrong.<ul> <li>In case of an error the <code>ErrorHandler</code> will convert the <code>Error</code> into a <code>ResponseDescription</code>.</li> </ul> </li> <li>Use the <code>ResponseWriter</code> to output the <code>ResponseDescription</code> as an HTTP response.</li> </ol>"},{"location":"architecture/features/protocol/parsing/#parsing-the-request","title":"Parsing the request","text":"<pre><code>flowchart TD\n  RequestParser(\"&lt;strong&gt;RequestParser&lt;/strong&gt;&lt;br&gt;BasicRequestParser\") --&gt; RequestParserArgs\n  subgraph RequestParserArgs[\" \"]\n    TargetExtractor(\"&lt;strong&gt;TargetExtractor&lt;/strong&gt;&lt;br&gt;OriginalUrlExtractor\")\n    PreferenceParser(\"&lt;strong&gt;PreferenceParser&lt;/strong&gt;&lt;br&gt;AcceptPreferenceParser\")\n    MetadataParser(\"&lt;strong&gt;MetadataParser&lt;/strong&gt;&lt;br&gt;&lt;i&gt;MetadataParser&lt;/i&gt;\")\n    BodyParser(\"&lt;br&gt;&lt;i&gt;Bodyparser&lt;/i&gt;\")\n    Conditions(\"&lt;br&gt;BasicConditionsParser\")\n  end\n\n  OriginalUrlExtractor --&gt; IdentifierStrategy(\"&lt;strong&gt;IdentifierStrategy&lt;/strong&gt;&lt;br&gt;&lt;i&gt;IdentifierStrategy&lt;/i&gt;\")</code></pre> <p>The <code>BasicRequestParser</code> is mostly an aggregator of multiple smaller parsers that each handle a very specific part.</p>"},{"location":"architecture/features/protocol/parsing/#url","title":"URL","text":"<p>This is a single class, the <code>OriginalUrlExtractor</code>, but fulfills the very important role of making sure input URLs are handled consistently.</p> <p>The query parameters will always be completely removed from the URL.</p> <p>There is also an algorithm to make sure all URLs have a \"canonical\" version as for example both <code>&amp;</code> and <code>%26</code> can be interpreted in the same way. Specifically all special characters will be encoded into their percent encoding.</p> <p>The <code>IdentifierStrategy</code> it gets as input is used to determine if the resulting URL is within the scope of the server. This can differ depending on if the server uses subdomains or not.</p> <p>The resulting identifier will be stored in the <code>target</code> field of an <code>Operation</code> object.</p>"},{"location":"architecture/features/protocol/parsing/#preferences","title":"Preferences","text":"<p>The <code>AcceptPreferenceParser</code> parses the <code>Accept</code> header and all the relevant <code>Accept-*</code> headers. These will all be put into the <code>preferences</code> field of an <code>Operation</code> object. These will later be used to handle the content negotiation.</p> <p>For example, when sending an <code>Accept: text/turtle; q=0.9</code> header, this wil result in the preferences object <code>{ type: { 'text/turtle': 0.9 } }</code>.</p>"},{"location":"architecture/features/protocol/parsing/#headers","title":"Headers","text":"<p>Several other headers can have relevant metadata, such as the <code>Content-Type</code> header, or the <code>Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel=\"type\"</code> header which is used to indicate to the server that a request intends to create a container.</p> <p>Such headers are converted to RDF triples and stored in the <code>RepresentationMetadata</code> object, which will be part of the <code>body</code> field in the <code>Operation</code>.</p> <p>The default <code>MetadataParser</code> is a <code>ParallelHandler</code> that contains several smaller parsers, each looking at a specific header.</p>"},{"location":"architecture/features/protocol/parsing/#body","title":"Body","text":"<p>In case of most requests, the input data stream is used directly in the <code>body</code> field of the <code>Operation</code>, with a few minor checks to make sure the HTTP specification is being followed.</p> <p>In the case of PATCH requests though, there are several specific body parsers that will convert the request into a JavaScript object containing all the necessary information to execute such a PATCH. Several validation checks will already take place there as well.</p>"},{"location":"architecture/features/protocol/parsing/#conditions","title":"Conditions","text":"<p>The <code>BasicConditionsParser</code> parses everything related to conditions headers, such as <code>if-none-match</code> or <code>if-modified-since</code>, and stores the relevant information in the <code>conditions</code> field of the <code>Operation</code>. These will later be used to make sure the request should be aborted or not.</p>"},{"location":"architecture/features/protocol/parsing/#sending-the-response","title":"Sending the response","text":"<p>In case a request is successful, the <code>AuthorizingHttpHandler</code> will return a <code>ResponseDescription</code>, and if not it will throw an error.</p> <p>In case an error gets thrown, this will be caught by the <code>ErrorHandler</code> and converted into a <code>ResponseDescription</code>. The request preferences will be used to make sure the serialization is one that is preferred.</p> <p>Either way we will have a <code>ResponseDescription</code>, which will be sent to the <code>BasicResponseWriter</code> to convert into output headers, data and a status code.</p> <p>To convert the metadata into headers, it uses a <code>MetadataWriter</code>, which functions as the reverse of the <code>MetadataParser</code> mentioned above: it has multiple writers which each convert certain metadata into a specific header.</p>"},{"location":"architecture/features/protocol/resource-store/","title":"Resource store","text":"<p>The interface of a <code>ResourceStore</code> is mostly a 1-to-1 mapping of the HTTP methods:</p> <ul> <li>GET: <code>getRepresentation</code></li> <li>PUT: <code>setRepresentation</code></li> <li>POST: <code>addResource</code></li> <li>DELETE: <code>deleteResource</code></li> <li>PATCH: <code>modifyResource</code></li> </ul> <p>The corresponding <code>OperationHandler</code> of the relevant method is responsible for calling the correct <code>ResourceStore</code> function.</p> <p>In practice, the community server has multiple resource stores chained together, each handling a specific part of the request and then calling the next store in the chain. The default configurations come with the following stores:</p> <ol> <li><code>MonitoringStore</code></li> <li><code>IndexRepresentationStore</code></li> <li><code>LockingResourceStore</code></li> <li><code>PatchingStore</code></li> <li><code>RepresentationConvertingStore</code></li> <li><code>DataAccessorBasedStore</code></li> </ol> <p>This chain can be seen in the configuration part in <code>config/storage/middleware/default.json</code> and all the entries in <code>config/storage/backend</code>.</p>"},{"location":"architecture/features/protocol/resource-store/#monitoringstore","title":"MonitoringStore","text":"<p>This store emits the events that are necessary to emit notifications when resources change.</p> <p>There are 4 different events that can be emitted:</p> <ul> <li><code>this.emit('changed', identifier, activity)</code>: is emitted for every resource that was changed/effected by a     call to the store.     With activity being undefined or one of the available ActivityStream terms.</li> <li><code>this.emit(AS.Create, identifier)</code>: is emitted for every resource that was created by the call to the store.</li> <li><code>this.emit(AS.Update, identifier)</code>: is emitted for every resource that was updated by the call to the store.</li> <li><code>this.emit(AS.Delete, identifier)</code>: is emitted for every resource that was deleted by the call to the store.</li> </ul> <p>A <code>changed</code> event will always be emitted if a resource was changed. If the correct metadata was set by the source <code>ResourceStore</code>, an additional field will be sent along indicating the type of change, and an additional corresponding event will be emitted, depending on what the change is.</p>"},{"location":"architecture/features/protocol/resource-store/#indexrepresentationstore","title":"IndexRepresentationStore","text":"<p>When doing a GET request on a container <code>/container/</code>, this container returns the contents of <code>/container/index.html</code> instead if HTML is the preferred response type. All these values are the defaults and can be configured for other resources and media types.</p>"},{"location":"architecture/features/protocol/resource-store/#lockingresourcestore","title":"LockingResourceStore","text":"<p>To prevent data corruption, the server locks resources when being targeted by a request. Locks are only released when an operation is completely finished, in the case of read operations this means the entire data stream is read, and in the case of write operations this happens when all relevant data is written. The default lock that is used is a readers-writer lock. This allows simultaneous read requests on the same resource, but only while no write request is in progress.</p>"},{"location":"architecture/features/protocol/resource-store/#patchingstore","title":"PatchingStore","text":"<p>PATCH operations in Solid apply certain transformations on the target resource, which makes them more complicated than only reading or writing data since it involves both. The <code>PatchingStore</code> provides a generic solution for backends that do not implement the <code>modifyResource</code> function so new backends can be added more easily. In case the next store in the chain does not support PATCH, the <code>PatchingStore</code> will GET the data from the next store, apply the transformation on that data, and then PUT it back to the store.</p>"},{"location":"architecture/features/protocol/resource-store/#representationconvertingstore","title":"RepresentationConvertingStore","text":"<p>This store handles everything related to content negotiation. In case the resulting data of a GET request does not match the preferences of a request, it will be converted here. Similarly, if incoming data does not match the type expected by the store, the SPARQL backend only accepts triples for example, that is also handled here</p>"},{"location":"architecture/features/protocol/resource-store/#dataaccessorbasedstore","title":"DataAccessorBasedStore","text":"<p>Large parts of the requirements of the Solid protocol specification are resolved by the <code>DataAccessorBasedStore</code>: POST only working on containers, DELETE not working on non-empty containers, generating <code>ldp:contains</code> triples for containers, etc. Most of this behaviour is independent of how the data is stored which is why it can be generalized here. The store's name comes from the fact that it makes use of <code>DataAccessor</code>s to handle the read/write of resources. A <code>DataAccessor</code> is a simple interface that only focuses on handling the data. It does not concern itself with any of the necessary Solid checks as it assumes those have already been made. This means that if a storage method needs to be supported, only a new <code>DataAccessor</code> needs to be made, after which it can be plugged into the rest of the server.</p>"},{"location":"contributing/making-changes/","title":"Pull requests","text":"<p>The community server is fully written in Typescript.</p> <p>All changes should be done through pull requests.</p> <p>We recommend first discussing a possible solution in the relevant issue to reduce the amount of changes that will be requested.</p> <p>In case any of your changes are breaking, make sure you target the next major branch (<code>versions/x.0.0</code>) instead of the main branch. Breaking changes include: changing interface/class signatures, potentially breaking external custom configurations, and breaking how internal data is stored. In case of doubt you probably want to target the next major branch.</p> <p>We make use of Conventional Commits.</p> <p>Don't forget to update the release notes when adding new major features. Also update any relevant documentation in case this is needed.</p> <p>When making changes to a pull request, we prefer to update the existing commits with a rebase instead of appending new commits, this way the PR can be rebased directly onto the target branch instead of needing to be squashed.</p> <p>There are strict requirements from the linter and the test coverage before a PR is valid. These are configured to run automatically when trying to commit to git. Although there are no tests for it (yet), we strongly advice documenting with TSdoc.</p> <p>If a list of entries is alphabetically sorted, such as index.ts, make sure it stays that way.</p>"},{"location":"contributing/release/","title":"Releasing a new version","text":"<p>This is only relevant if you are a developer with push access responsible for doing a new release.</p> <p>Steps to follow:</p> <ul> <li>Merge <code>main</code> into <code>versions/x.0.0</code>.</li> <li>Verify if there are issues when upgrading an existing installation to the new version.<ul> <li>Can the data still be accessed?</li> <li>Does authentication still work?</li> <li>Is there an issue upgrading any of the dependent repositories (see below for links)?</li> <li>None of the above has to be blocking per se, but should be noted in the release notes if relevant.</li> </ul> </li> <li>Verify that the <code>RELEASE_NOTES.md</code> are correct.</li> <li><code>npm run release -- -r major</code><ul> <li>Automatically updates Components.js references to the new version.   Committed with <code>chore(release): Update configs to vx.0.0</code>.</li> <li>Updates the <code>package.json</code>, and generates the new entries in <code>CHANGELOG.md</code>.   Commited with <code>chore(release): Release version vx.0.0 of the npm package</code></li> <li>Optionally run <code>npx commit-and-tag-version -r major --dry-run</code> to preview the commands that will be run   and the changes to <code>CHANGELOG.md</code>.</li> </ul> </li> <li>The <code>postrelease</code> script will now prompt you to manually edit the <code>CHANGELOG.md</code>.<ul> <li>All entries are added in separate sections of the new release according to their commit prefixes.</li> <li>Re-organize the entries accordingly, referencing previous releases. Most of the entries in Chores and   Documentation can be removed.</li> <li>Press any key in your terminal when your changes are ready.</li> <li>The <code>postrelease</code> script will amend the release commit, create an annotated tag and push changes to origin.</li> </ul> </li> <li>Merge <code>versions/x.0.0</code> into <code>main</code> and push.</li> <li>Do a GitHub release.</li> <li><code>npm publish</code><ul> <li>Check if there is a <code>next</code> tag that needs to be replaced.</li> </ul> </li> <li>Rename the <code>versions/x.0.0</code> branch to the next version.</li> <li>Update <code>.github/workflows/schedule.yml</code> and <code>.github/dependabot.yml</code> to point at the new branch.</li> <li>Potentially upgrade dependent repositories:<ul> <li>Recipes at https://github.com/CommunitySolidServer/recipes/</li> <li>Tutorials at https://github.com/CommunitySolidServer/tutorials/</li> </ul> </li> </ul> <p>Changes when doing a pre-release of a major version:</p> <ul> <li>Version with <code>npm run release -- -r major --prerelease alpha</code></li> <li>Do not merge <code>versions/x.0.0</code> into <code>main</code>.</li> <li>Publish with <code>npm publish --tag next</code>.</li> <li>Do not update the branch or anything related.</li> </ul>"},{"location":"usage/client-credentials/","title":"Automating authentication with Client Credentials","text":"<p>One potential issue for scripts and other applications is that it requires user interaction to log in and authenticate. The CSS offers an alternative solution for such cases by making use of Client Credentials. Once you have created an account as described in the Identity Provider section, users can request a token that apps can use to authenticate without user input.</p> <p>All requests to the client credentials API currently require you to send along the email and password of that account to identify yourself. This is a temporary solution until the server has more advanced account management, after which this API will change.</p> <p>Below is example code of how to make use of these tokens. It makes use of several utility functions from the Solid Authentication Client. Note that the code below uses top-level <code>await</code>, which not all JavaScript engines support, so this should all be contained in an <code>async</code> function.</p>"},{"location":"usage/client-credentials/#generating-a-token","title":"Generating a token","text":"<p>The code below generates a token linked to your account and WebID. This only needs to be done once, afterwards this token can be used for all future requests.</p> <pre><code>import fetch from 'node-fetch';\n\n// This assumes your server is started under http://localhost:3000/.\n// This URL can also be found by checking the controls in JSON responses when interacting with the IDP API,\n// as described in the Identity Provider section.\nconst response = await fetch('http://localhost:3000/idp/credentials/', {\nmethod: 'POST',\nheaders: { 'content-type': 'application/json' },\n// The email/password fields are those of your account.\n// The name field will be used when generating the ID of your token.\nbody: JSON.stringify({ email: 'my-email@example.com', password: 'my-account-password', name: 'my-token' }),\n});\n\n// These are the identifier and secret of your token.\n// Store the secret somewhere safe as there is no way to request it again from the server!\nconst { id, secret } = await response.json();\n</code></pre> <p>If there is something wrong with your input the response code will be 500. If no account is linked to the email, the message will be \"Account does not exist\" and if the password is wrong it will be \"Incorrect password\".</p>"},{"location":"usage/client-credentials/#requesting-an-access-token","title":"Requesting an Access token","text":"<p>The ID and secret combination generated above can be used to request an Access Token from the server. This Access Token is only valid for a certain amount of time, after which a new one needs to be requested.</p> <pre><code>import { createDpopHeader, generateDpopKeyPair } from '@inrupt/solid-client-authn-core';\nimport fetch from 'node-fetch';\n\n// A key pair is needed for encryption.\n// This function from `solid-client-authn` generates such a pair for you.\nconst dpopKey = await generateDpopKeyPair();\n\n// These are the ID and secret generated in the previous step.\n// Both the ID and the secret need to be form-encoded.\nconst authString = `${encodeURIComponent(id)}:${encodeURIComponent(secret)}`;\n// This URL can be found by looking at the \"token_endpoint\" field at\n// http://localhost:3000/.well-known/openid-configuration\n// if your server is hosted at http://localhost:3000/.\nconst tokenUrl = 'http://localhost:3000/.oidc/token';\nconst response = await fetch(tokenUrl, {\nmethod: 'POST',\nheaders: {\n// The header needs to be in base64 encoding.\nauthorization: `Basic ${Buffer.from(authString).toString('base64')}`,\n'content-type': 'application/x-www-form-urlencoded',\ndpop: await createDpopHeader(tokenUrl, 'POST', dpopKey),\n},\nbody: 'grant_type=client_credentials&amp;scope=webid',\n});\n\n// This is the Access token that will be used to do an authenticated request to the server.\n// The JSON also contains an \"expires_in\" field in seconds,\n// which you can use to know when you need request a new Access token.\nconst { access_token: accessToken } = await response.json();\n</code></pre>"},{"location":"usage/client-credentials/#using-the-access-token-to-make-an-authenticated-request","title":"Using the Access token to make an authenticated request","text":"<p>Once you have an Access token, you can use it for authenticated requests until it expires.</p> <pre><code>import { buildAuthenticatedFetch } from '@inrupt/solid-client-authn-core';\nimport fetch from 'node-fetch';\n\n// The DPoP key needs to be the same key as the one used in the previous step.\n// The Access token is the one generated in the previous step.\nconst authFetch = await buildAuthenticatedFetch(fetch, accessToken, { dpopKey });\n// authFetch can now be used as a standard fetch function that will authenticate as your WebID.\n// This request will do a simple GET for example.\nconst response = await authFetch('http://localhost:3000/private');\n</code></pre>"},{"location":"usage/client-credentials/#deleting-a-token","title":"Deleting a token","text":"<p>You can see all your existing tokens by doing a POST to <code>http://localhost:3000/idp/credentials/</code> with as body a JSON object containing your email and password. The response will be a JSON list containing all your tokens.</p> <p>Deleting a token requires also doing a POST to the same URL, but adding a <code>delete</code> key to the JSON input object with as value the ID of the token you want to remove.</p>"},{"location":"usage/dev-configuration/","title":"Configuring the CSS as a development server in another project","text":"<p>It can be useful to use the CSS as local server to develop Solid applications against. As an alternative to using CLI arguments, or environment variables, the CSS can be configured in the <code>package.json</code> as follows:</p> <pre><code>{\n\"name\": \"test\",\n\"version\": \"0.0.0\",\n\"private\": \"true\",\n\"config\": {\n\"community-solid-server\": {\n\"port\": 3001,\n\"loggingLevel\": \"error\"\n}\n},\n\"scripts\": {\n\"dev:pod\": \"community-solid-server\"\n},\n\"devDependencies\": {\n\"@solid/community-server\": \"^6.0.0\"\n}\n}\n</code></pre> <p>These parameters will then be used when the <code>community-solid-server</code> command is executed as an npm script (as shown in the example above). Or whenever the <code>community-solid-server</code> command is executed in the same folder as the <code>package.json</code>.</p> <p>Alternatively, the configuration parameters may be placed in a configuration file named <code>.community-solid-server.config.json</code> as follows:</p> <pre><code>{\n\"port\": 3001,\n\"loggingLevel\": \"error\"\n}\n</code></pre> <p>The config may also be written in JavaScript with the config as the default export such as the following <code>.community-solid-server.config.js</code>:</p> <pre><code>module.exports = {\nport: 3001,\nloggingLevel: \"error\"\n};\n</code></pre>"},{"location":"usage/example-requests/","title":"Interacting with the server","text":""},{"location":"usage/example-requests/#put-creating-resources-for-a-given-url","title":"<code>PUT</code>: Creating resources for a given URL","text":"<p>Create a plain text file:</p> <pre><code>curl -X PUT -H \"Content-Type: text/plain\" \\\n-d \"abc\" \\\nhttp://localhost:3000/myfile.txt\n</code></pre> <p>Create a turtle file:</p> <pre><code>curl -X PUT -H \"Content-Type: text/turtle\" \\\n-d \"&lt;ex:s&gt; &lt;ex:p&gt; &lt;ex:o&gt;.\" \\\nhttp://localhost:3000/myfile.ttl\n</code></pre>"},{"location":"usage/example-requests/#post-creating-resources-at-a-generated-url","title":"<code>POST</code>: Creating resources at a generated URL","text":"<p>Create a plain text file:</p> <pre><code>curl -X POST -H \"Content-Type: text/plain\" \\\n-d \"abc\" \\\nhttp://localhost:3000/\n</code></pre> <p>Create a turtle file:</p> <pre><code>curl -X POST -H \"Content-Type: text/turtle\" \\\n-d \"&lt;ex:s&gt; &lt;ex:p&gt; &lt;ex:o&gt;.\" \\\nhttp://localhost:3000/\n</code></pre> <p>The response's <code>Location</code> header will contain the URL of the created resource.</p>"},{"location":"usage/example-requests/#get-retrieving-resources","title":"<code>GET</code>: Retrieving resources","text":"<p>Retrieve a plain text file:</p> <pre><code>curl -H \"Accept: text/plain\" \\\nhttp://localhost:3000/myfile.txt\n</code></pre> <p>Retrieve a turtle file:</p> <pre><code>curl -H \"Accept: text/turtle\" \\\nhttp://localhost:3000/myfile.ttl\n</code></pre> <p>Retrieve a turtle file in a different serialization:</p> <pre><code>curl -H \"Accept: application/ld+json\" \\\nhttp://localhost:3000/myfile.ttl\n</code></pre>"},{"location":"usage/example-requests/#delete-deleting-resources","title":"<code>DELETE</code>: Deleting resources","text":"<pre><code>curl -X DELETE http://localhost:3000/myfile.txt\n</code></pre>"},{"location":"usage/example-requests/#patch-modifying-resources","title":"<code>PATCH</code>: Modifying resources","text":"<p>Modify a resource using N3 Patch:</p> <pre><code>curl -X PATCH -H \"Content-Type: text/n3\" \\\n--data-raw \"@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;. _:rename a solid:InsertDeletePatch; solid:inserts { &lt;ex:s2&gt; &lt;ex:p2&gt; &lt;ex:o2&gt;. }.\" \\\nhttp://localhost:3000/myfile.ttl\n</code></pre> <p>Modify a resource using SPARQL Update:</p> <pre><code>curl -X PATCH -H \"Content-Type: application/sparql-update\" \\\n-d \"INSERT DATA { &lt;ex:s2&gt; &lt;ex:p2&gt; &lt;ex:o2&gt; }\" \\\nhttp://localhost:3000/myfile.ttl\n</code></pre>"},{"location":"usage/example-requests/#head-retrieve-resources-headers","title":"<code>HEAD</code>: Retrieve resources headers","text":"<pre><code>curl -I -H \"Accept: text/plain\" \\\nhttp://localhost:3000/myfile.txt\n</code></pre>"},{"location":"usage/example-requests/#options-retrieve-resources-communication-options","title":"<code>OPTIONS</code>: Retrieve resources communication options","text":"<pre><code>curl -X OPTIONS -i http://localhost:3000/myfile.txt\n</code></pre>"},{"location":"usage/identity-provider/","title":"Identity Provider","text":"<p>Besides implementing the Solid protocol, the community server can also be an Identity Provider (IDP), officially known as an OpenID Provider (OP), following the Solid OIDC spec as much as possible.</p> <p>It is recommended to use the latest version of the Solid authentication client to interact with the server.</p> <p>The links here assume the server is hosted at <code>http://localhost:3000/</code>.</p>"},{"location":"usage/identity-provider/#registering-an-account","title":"Registering an account","text":"<p>To register an account, you can go to <code>http://localhost:3000/idp/register/</code> if this feature is enabled, which it is on all configurations we provide. Currently our registration page ties 3 features together on the same page:</p> <ul> <li>Creating an account on the server.</li> <li>Creating or linking a WebID to your account.</li> <li>Creating a pod on the server.</li> </ul>"},{"location":"usage/identity-provider/#account","title":"Account","text":"<p>To create an account you need to provide an email address and password. The password will be salted and hashed before being stored. As of now, the account is only used to log in and identify yourself to the IDP when you want to do an authenticated request, but in future the plan is to also use this for account/pod management.</p>"},{"location":"usage/identity-provider/#webid","title":"WebID","text":"<p>We require each account to have a corresponding WebID. You can either let the server create a WebID for you in a pod, which will also need to be created then, or you can link an already existing WebID you have on an external server.</p> <p>In case you try to link your own WebID, you can choose if you want to be able to use this server as your IDP for this WebID. If not, you can still create a pod, but you will not be able to direct the authentication client to this server to identify yourself.</p> <p>Additionally, if you try to register with an external WebID, the first attempt will return an error indicating you need to add an identification triple to your WebID. After doing that you can try to register again. This is how we verify you are the owner of that WebID. After registration the next page will inform you that you have to add an additional triple to your WebID if you want to use the server as your IDP.</p> <p>All of the above is automated if you create the WebID on the server itself.</p>"},{"location":"usage/identity-provider/#pod","title":"Pod","text":"<p>To create a pod you simply have to fill in the name you want your pod to have. This will then be used to generate the full URL of your pod. For example, if you choose the name <code>test</code>, your pod would be located at <code>http://localhost:3000/test/</code> and your generated WebID would be <code>http://localhost:3000/test/profile/card#me</code>.</p> <p>The generated name also depends on the configuration you chose for your server. If you are using the subdomain feature, such as being done in the <code>config/memory-subdomains.json</code> configuration, the generated pod URL would be <code>http://test.localhost:3000/</code>.</p>"},{"location":"usage/identity-provider/#logging-in","title":"Logging in","text":"<p>When using an authenticating client, you will be redirected to a login screen asking for your email and password. After that you will be redirected to a page showing some basic information about the client. There you need to consent that this client is allowed to identify using your WebID. As a result the server will send a token back to the client that contains all the information needed to use your WebID.</p>"},{"location":"usage/identity-provider/#forgot-password","title":"Forgot password","text":"<p>If you forgot your password, you can recover it by going to <code>http://localhost:3000/idp/forgotpassword/</code>. There you can enter your email address to get a recovery mail to reset your password. This feature only works if a mail server was configured, which by default is not the case.</p>"},{"location":"usage/identity-provider/#json-api","title":"JSON API","text":"<p>All of the above happens through HTML pages provided by the server. By default, the server uses the templates found in <code>/templates/identity/email-password/</code> but different templates can be used through configuration.</p> <p>These templates all make use of a JSON API exposed by the server. For example, when doing a GET request to <code>http://localhost:3000/idp/register/</code> with a JSON accept header, the following JSON is returned:</p> <pre><code>{\n\"required\": {\n\"email\": \"string\",\n\"password\": \"string\",\n\"confirmPassword\": \"string\",\n\"createWebId\": \"boolean\",\n\"register\": \"boolean\",\n\"createPod\": \"boolean\",\n\"rootPod\": \"boolean\"\n},\n\"optional\": {\n\"webId\": \"string\",\n\"podName\": \"string\",\n\"template\": \"string\"\n},\n\"controls\": {\n\"register\": \"http://localhost:3000/idp/register/\",\n\"index\": \"http://localhost:3000/idp/\",\n\"prompt\": \"http://localhost:3000/idp/prompt/\",\n\"login\": \"http://localhost:3000/idp/login/\",\n\"forgotPassword\": \"http://localhost:3000/idp/forgotpassword/\"\n},\n\"apiVersion\": \"0.3\"\n}\n</code></pre> <p>The <code>required</code> and <code>optional</code> fields indicate which input fields are expected by the API. These correspond to the fields of the HTML registration page. To register a user, you can do a POST request with a JSON body containing the correct fields:</p> <pre><code>{\n\"email\": \"test@example.com\",\n\"password\": \"secret\",\n\"confirmPassword\": \"secret\",\n\"createWebId\": true,\n\"register\": true,\n\"createPod\": true,\n\"rootPod\": false,\n\"podName\": \"test\"\n}\n</code></pre> <p>Two fields here that are not covered on the HTML page above are <code>rootPod</code> and <code>template</code>. <code>rootPod</code> tells the server to put the pod in the root of the server instead of a location based on the <code>podName</code>. By default the server will reject requests where this is <code>true</code>, except during setup. <code>template</code> is only used by servers running the <code>config/dynamic.json</code> configuration, which is a very custom setup where every pod can have a different Components.js configuration, so this value can usually be ignored.</p>"},{"location":"usage/identity-provider/#idp-configuration","title":"IDP configuration","text":"<p>The above descriptions cover server behaviour with most default configurations, but just like any other feature, there are several features that can be changed through the imports in your configuration file.</p> <p>All available options can be found in the <code>config/identity/</code> folder. Below we go a bit deeper into the available options</p>"},{"location":"usage/identity-provider/#access","title":"access","text":"<p>The <code>access</code> option allows you to set authorization restrictions on the IDP API when enabled, similar to how authorization works on the LDP requests on the server. For example, if the server uses WebACL as authorization scheme, you can put a <code>.acl</code> resource in the <code>/idp/register/</code> container to restrict who is allowed to access the registration API. Note that for everything to work there needs to be a <code>.acl</code> resource in <code>/idp/</code> when using WebACL so resources can be accessed as usual when the server starts up. Make sure you change the permissions on <code>/idp/.acl</code> so not everyone can modify those.</p> <p>All of the above is only relevant if you use the <code>restricted.json</code> setting for this import. When you use <code>public.json</code> the API will simply always be accessible by everyone.</p>"},{"location":"usage/identity-provider/#email","title":"email","text":"<p>In case you want users to be able to reset their password when they forget it, you will need to tell the server which email server to use to send reset mails. <code>example.json</code> contains an example of what this looks like, which you will need to copy over to your base configuration and then remove the <code>config/identity/email</code> import.</p>"},{"location":"usage/identity-provider/#handler","title":"handler","text":"<p>There is only one option here. This import contains all the core components necessary to make the IDP work. In case you need to make some changes to core IDP settings, this is where you would have to look.</p>"},{"location":"usage/identity-provider/#pod_1","title":"pod","text":"<p>The <code>pod</code> options determines how pods are created. <code>static.json</code> is the expected pod behaviour as described above. <code>dynamic.json</code> is an experimental feature that allows users to have a custom Components.js configuration for their own pod. When using such a setup, a JSON file will be written containing all the information of the user pods so they can be recreated when the server restarts.</p>"},{"location":"usage/identity-provider/#registration","title":"registration","text":"<p>This setting allows you to enable/disable registration on the server. Disabling registration here does not disable registration during setup, meaning you can still use this server as an IDP with the account created there.</p>"},{"location":"usage/metadata/","title":"Editing metadata of resources","text":""},{"location":"usage/metadata/#what-is-a-description-resource","title":"What is a description resource","text":"<p>Description resources contain auxiliary information about a resource. In CSS, these represent metadata corresponding to that resource. Every resource always has a corresponding description resource and therefore description resources can not be created or deleted directly.</p> <p>Description resources are discoverable by interacting with their subject resource: the response to a <code>GET</code> or <code>HEAD</code> request on a subject resource will contain a <code>describedby</code> Link Header with a URL that points to its description resource.</p> <p>Clients should always follow this link rather than guessing its URL, because the Solid Protocol does not mandate a specific description resource URL. The default CSS configurations use as a convention that <code>http://example.org/resource</code> has <code>http://example.org/resource.meta</code> as its description resource.</p>"},{"location":"usage/metadata/#how-to-edit-the-metadata-of-a-resource","title":"How to edit the metadata of a resource","text":"<p>Editing the metadata of a resource is performed by editing the description resource directly. This can only be done using <code>PATCH</code> requests (see example workflow).</p> <p><code>PUT</code> requests on description resources are not allowed, because they would replace the entire resource state, whereas some metadata is protected or generated by the server.</p> <p>Similarly, <code>DELETE</code> on description resources is not allowed because a resource will always have some metadata (e.g. <code>rdf:type</code>). Instead, the lifecycle of description resources is managed by the server.</p>"},{"location":"usage/metadata/#protected-metadata","title":"Protected metadata","text":"<p>Some metadata is managed by the server and can not be modified directly, such as the last modified date. The CSS will throw an error (409 <code>ConflictHttpError</code>) when trying to change this protected metadata.</p>"},{"location":"usage/metadata/#preserving-metadata","title":"Preserving metadata","text":"<p><code>PUT</code> requests on a resource will reset the description resource. There is however a way to keep the contents of description resource prior to the <code>PUT</code> request: adding the HTTP <code>Link</code> header targeting the description resource with <code>rel=\"preserve\"</code>.</p> <p>When the resource URL is <code>http://localhost:3000/foobar</code>, preserving its description resource when updating its contents can be achieved like in the following example:</p> <pre><code>curl -X PUT 'http://localhost:3000/foobar' \\\n-H 'Content-Type: text/turtle' \\\n-H 'Link: &lt;http://localhost:3000/foobar.meta&gt;;rel=\"preserve\"' \\\n-d \"&lt;ex:s&gt; &lt;ex:p&gt; &lt;ex:o&gt;.\"\n</code></pre>"},{"location":"usage/metadata/#impact-on-creating-containers","title":"Impact on creating containers","text":"<p>When creating a container the input body is ignored and performing a <code>PUT</code> request on an existing container will result in an error. Container metadata can only be added and modified by performing a <code>PATCH</code> on the description resource, similarly to documents. This is done to clearly differentiate between a container's representation and its metadata.</p>"},{"location":"usage/metadata/#example-of-a-workflow-for-editing-a-description-resource","title":"Example of a workflow for editing a description resource","text":"<p>In this example, we add an inbox description to <code>http://localhost:3000/foo/</code>. This allows discovery of the <code>ldp:inbox</code> as described in the Linked Data Notifications specification.</p> <p>We have started the CSS with the default configuration and have already created an inbox at <code>http://localhost:3000/inbox/</code>.</p> <p>Since we don't know the location of the description resource, we first send a <code>HEAD</code> request to the resource to obtain the URL of its description resource.</p> <pre><code>curl --head 'http://localhost:3000/foo/'\n</code></pre> <p>which will produce a response with at least these headers:</p> <pre><code>HTTP/1.1 200 OK\nLink: &lt;http://localhost:3000/foo/.meta&gt;; rel=\"describedby\"\n</code></pre> <p>Now that we have the URL of the description resource, we create a patch for adding the inbox in the description of the resource.</p> <pre><code>curl -X PATCH 'http://localhost:3000/foo/.meta' \\\n-H 'Content-Type: text/n3' \\\n--data-raw '@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.\n&lt;&gt; a solid:InsertDeletePatch;\nsolid:inserts { &lt;http://localhost:3000/foo/&gt; &lt;http://www.w3.org/ns/ldp#inbox&gt; &lt;http://localhost:3000/inbox/&gt;. }.'\n</code></pre> <p>After this update, we can verify that the inbox is added by performing a GET request to the description resource</p> <pre><code>curl 'http://localhost:3000/foo/.meta'\n</code></pre> <p>With as result for the body</p> <pre><code>@prefix dc: &lt;http://purl.org/dc/terms/&gt;.\n@prefix ldp: &lt;http://www.w3.org/ns/ldp#&gt;.\n@prefix posix: &lt;http://www.w3.org/ns/posix/stat#&gt;.\n@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.\n\n&lt;http://localhost:3000/foo/&gt; a ldp:Container, ldp:BasicContainer, ldp:Resource;\n    dc:modified \"2022-06-09T08:17:07.000Z\"^^xsd:dateTime;\n    ldp:inbox &lt;http://localhost:3000/inbox/&gt;;.\n</code></pre> <p>This can also be verified by sending a GET request to the subject resource itself. The inbox location can also be found in the Link headers.</p> <pre><code>curl -v 'http://localhost:3000/foo/'\n</code></pre> <pre><code>HTTP/1.1 200 OK\nLink: &lt;http://localhost:3000/inbox/&gt;; rel=\"http://www.w3.org/ns/ldp#inbox\"\n</code></pre>"},{"location":"usage/seeding-pods/","title":"How to seed Accounts and Pods","text":"<p>If you need to seed accounts and pods, the <code>--seededPodConfigJson</code> command line option can be used with as value the path to a JSON file containing configurations for every required pod. The file needs to contain an array of JSON objects, with each object containing at least a <code>podName</code>, <code>email</code>, and <code>password</code> field.</p> <p>For example:</p> <pre><code>[\n{\n\"podName\": \"example\",\n\"email\": \"hello@example.com\",\n\"password\": \"abc123\"\n}\n]\n</code></pre> <p>You may optionally specify other parameters as described in the Identity Provider documentation.</p> <p>For example, to set up a pod without registering the generated WebID with the Identity Provider:</p> <pre><code>[\n{\n\"podName\": \"example\",\n\"email\": \"hello@example.com\",\n\"password\": \"abc123\",\n\"webId\": \"https://id.inrupt.com/example\",\n\"register\": false\n}\n]\n</code></pre> <p>This feature cannot be used to register pods with pre-existing WebIDs, which requires an interactive validation step.</p>"}]}