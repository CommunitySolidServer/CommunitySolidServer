import type { StringSchema } from 'yup';
import { object, string } from 'yup';
import type { ResourceIdentifier } from '../../../http/representation/ResourceIdentifier';
import { getLoggerFor } from '../../../logging/LogUtil';
import type { IdentifierGenerator } from '../../../pods/generate/IdentifierGenerator';
import type { PodSettings } from '../../../pods/settings/PodSettings';
import { BadRequestHttpError } from '../../../util/errors/BadRequestHttpError';
import { joinUrl } from '../../../util/PathUtil';
import type { AccountStore } from '../account/util/AccountStore';
import { getRequiredAccount } from '../account/util/AccountUtil';
import type { JsonRepresentation } from '../InteractionUtil';
import { JsonInteractionHandler } from '../JsonInteractionHandler';
import type { JsonInteractionHandlerInput } from '../JsonInteractionHandler';
import type { JsonView } from '../JsonView';
import type { WebIdStore } from '../webid/util/WebIdStore';
import { parseSchema, URL_SCHEMA, validateWithError } from '../YupUtil';
import type { PodStore } from './util/PodStore';

const inSchema = object({
  name: string().trim().min(1).optional(),
  settings: object({
    webId: URL_SCHEMA,
  }).optional(),
});

export interface CreatePodHandlerArgs {
  /**
   * Base URL of the server.
   * Used to potentially set the `solid:oidcIssuer` triple
   * and/or the pod URL if it is a root pod.
   */
  baseUrl: string;
  /**
   * Generates the base URL of the pod based on the input `name`.
   */
  identifierGenerator: IdentifierGenerator;
  /**
   * The path of where the WebID will be generated by the template, relative to the pod URL.
   */
  relativeWebIdPath: string;
  /**
   * Account data store.
   */
  accountStore: AccountStore;
  /**
   * WebID data store.
   */
  webIdStore: WebIdStore;
  /**
   * Pod data store.
   */
  podStore: PodStore;
  /**
   * Whether it is allowed to generate a pod in the root of the server.
   */
  allowRoot: boolean;
}

type OutType = {
  pod: string;
  podResource: string;
  webId: string;
  webIdResource?: string;
};

/**
 * Handles the creation of pods.
 * Will call the stored {@link PodStore} with the settings found in the input JSON.
 */
export class CreatePodHandler extends JsonInteractionHandler<OutType> implements JsonView {
  private readonly logger = getLoggerFor(this);

  private readonly baseUrl: string;
  private readonly identifierGenerator: IdentifierGenerator;
  private readonly relativeWebIdPath: string;
  private readonly accountStore: AccountStore;
  private readonly webIdStore: WebIdStore;
  private readonly podStore: PodStore;

  private readonly inSchema: typeof inSchema;

  public constructor(args: CreatePodHandlerArgs) {
    super();
    this.baseUrl = args.baseUrl;
    this.identifierGenerator = args.identifierGenerator;
    this.relativeWebIdPath = args.relativeWebIdPath;
    this.accountStore = args.accountStore;
    this.webIdStore = args.webIdStore;
    this.podStore = args.podStore;

    this.inSchema = inSchema.clone();

    if (!args.allowRoot) {
      // Casting is necessary to prevent errors
      this.inSchema.fields.name = (this.inSchema.fields.name as StringSchema).required();
    }
  }

  public async getView(): Promise<JsonRepresentation> {
    return { json: parseSchema(this.inSchema) };
  }

  public async handle({ json, accountId }: JsonInteractionHandlerInput): Promise<JsonRepresentation<OutType>> {
    const account = await getRequiredAccount(this.accountStore, accountId);

    // In case the class was not initialized with allowRoot: false, missing name values will result in an error
    const { name, settings } = await validateWithError(inSchema, json);

    const baseIdentifier = this.generateBaseIdentifier(name);
    // Either the input WebID or the one generated in the pod
    const webId = settings?.webId ?? joinUrl(baseIdentifier.path, this.relativeWebIdPath);
    const linkWebId = !settings?.webId;

    const podSettings: PodSettings = {
      ...settings,
      base: baseIdentifier,
      webId,
    };

    // Link the WebID to the account immediately if no WebID was provided.
    // This WebID will be necessary anyway to access the data in the pod,
    // so might as well link it to the account immediately.
    let webIdResource: string | undefined;
    if (linkWebId) {
      // It is important that this check happens here.
      // Otherwise, if the account already has this WebID link,
      // this link would be deleted if pod creation fails,
      // since we clean up the WebID link again afterwards.
      // Current implementation of the {@link WebIdStore} also has this check but better safe than sorry.
      if (account.webIds[webId]) {
        this.logger.warn('Trying to create pod which would generate a WebID that already is linked to this account');
        throw new BadRequestHttpError(`${webId} is already registered to this account.`);
      }

      webIdResource = await this.webIdStore.add(webId, account);
      // Need to have the necessary `solid:oidcIssuer` triple if the WebID is linked
      podSettings.oidcIssuer = this.baseUrl;
    }

    // Create the pod
    let podResource: string;
    try {
      podResource = await this.podStore.create(account, podSettings, !name);
    } catch (error: unknown) {
      // Undo the WebID linking if pod creation fails
      if (linkWebId) {
        // There was an error while trying to update the account above,
        // so we shouldn't assume the account object we have is still valid.
        const currentAccount = await getRequiredAccount(this.accountStore, accountId);
        await this.webIdStore.delete(webId, currentAccount);
      }

      throw error;
    }

    return { json: { pod: baseIdentifier.path, webId, podResource, webIdResource }};
  }

  private generateBaseIdentifier(name?: string): ResourceIdentifier {
    if (name) {
      return this.identifierGenerator.generate(name);
    }
    return { path: this.baseUrl };
  }
}
