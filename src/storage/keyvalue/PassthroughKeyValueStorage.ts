import type { KeyValueStorage } from './KeyValueStorage';

/**
 * Abstract class to create a {@link KeyValueStorage} by wrapping around another one.
 *
 * Exposes abstract functions to modify the key before passing it to the the source storage.
 */
export abstract class PassthroughKeyValueStorage<TVal> implements KeyValueStorage<string, TVal> {
  protected readonly source: KeyValueStorage<string, TVal>;

  protected constructor(source: KeyValueStorage<string, TVal>) {
    this.source = source;
  }

  public async get(key: string): Promise<TVal | undefined> {
    const path = this.toNewKey(key);
    return this.source.get(path);
  }

  public async has(key: string): Promise<boolean> {
    const path = this.toNewKey(key);
    return this.source.has(path);
  }

  public async set(key: string, value: TVal): Promise<this> {
    const path = this.toNewKey(key);
    await this.source.set(path, value);
    return this;
  }

  public async delete(key: string): Promise<boolean> {
    const path = this.toNewKey(key);
    return this.source.delete(path);
  }

  public async* entries(): AsyncIterableIterator<[string, TVal]> {
    for await (const [ path, value ] of this.source.entries()) {
      const key = this.toOriginalKey(path);
      yield [ key, value ];
    }
  }

  /**
   * This function will be called on the input key and used as a new key when calling the source.
   *
   * @param key - Original input key.
   *
   * @returns A new key to use with the source storage.
   */
  protected abstract toNewKey(key: string): string;

  /**
   * This function is used when calling `entries()` to revert the key generated by `toNewKey()`.
   *
   * @param key - A key generated by `toNewKey()`
   *
   * @returns The original key.
   */
  protected abstract toOriginalKey(key: string): string;
}
