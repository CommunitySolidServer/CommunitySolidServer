{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Welcome to the Community Solid Server! Here we will cover many aspects of the server, such as how to propose changes, what the architecture looks like, and how to use many of the features the server provides.</p> <p>The documentation here is still incomplete both in content and structure, so feel free to open a discussion about things you want to see added. While we try to update this documentation together with updates in the code, it is always possible we miss something, so please report it if you find incorrect information or links that no longer work.</p> <p>An introductory tutorial that gives a quick overview of the Solid and CSS basics can be found here. This is a good way to get started with the server and its setup.</p> <p>If you want to know what is new in the latest version, you can check out the release notes for a high level overview and information on how to migrate your configuration to the next version. A list that includes all minor changes can be found in the changelog</p>"},{"location":"#using-the-server","title":"Using the server","text":"<ul> <li>An overview of the main features of the server</li> <li>Quickly starting the server</li> <li>Basic example HTTP requests</li> <li>Editing the metadata of a resource</li> <li>How to use the Identity Provider and accounts</li> <li>How to automate authentication</li> <li>How to automatically seed pods on startup</li> <li>Receiving notifications when resources change</li> <li>Using the CSS as a development server in another project</li> <li>Which authorization method to pick</li> </ul>"},{"location":"#what-the-internals-look-like","title":"What the internals look like","text":"<ul> <li>How the server uses dependency injection</li> <li>What the architecture looks like</li> </ul>"},{"location":"#comprehensive-guides-and-tutorials","title":"Comprehensive guides and tutorials","text":"<ul> <li>The CSS tutorial repository</li> <li>CSS configuration generator</li> </ul>"},{"location":"#making-changes","title":"Making changes","text":"<ul> <li>How to make changes to the repository</li> </ul> <p>For core developers with push access only:</p> <ul> <li>How to release a new version</li> </ul>"},{"location":"features/","title":"Features","text":"<p>Below is a non-exhaustive listing of the features available to a server instance, depending on the chosen configuration. The core feature of the CSS is that it uses dependency injection to configure its components, so any of the features below can always be adapted or replaced with custom components if required. It can also be used to configure dummy components for debugging, development, or experimentation purposes. See this tutorial and/or this example repository for more information on that.</p> <p>To generate configurations with some of these features enabled/disabled, you can use the configuration generator.</p>"},{"location":"features/#authentication","title":"Authentication","text":"<p>Clients are identified based on the contents of DPoP tokens, as described in the Solid-OIDC specification.</p> <p>The server also provides several dummy components that can be used here, to either always identify the client as a fixed WebID, or to allow the WebID to be set directly in the <code>Authorization</code> header. These can be configured by changing the <code>ldp/authentication</code> import in your configuration.</p>"},{"location":"features/#authorization","title":"Authorization","text":"<p>Two authorization mechanisms are implemented for determining who has access to resources:</p> <ul> <li>Web Access Control</li> <li>Access Control Policy</li> </ul> <p>Alternatively, the server can be configured to not have any kind of authorization and allow full access to all resources.</p>"},{"location":"features/#solid-protocol","title":"Solid Protocol","text":"<p>The Solid Protocol is supported.</p> <p>Requests to the server support content negotiation for common RDF formats.</p> <p>Binary range headers are supported.</p> <p><code>ETag</code> and <code>Last-Modified</code> headers are supported. These can be used for conditional requests.</p> <p><code>PATCH</code> requests targeting RDF resources can be made with N3 Patch or SPARQL Update bodies.</p> <p>The server can be configured to store data in memory, on the file system, or through a SPARQL endpoint. Similarly, the locking system that is used to prevent data conflicts can be configured to store locks in memory, on the file system, or in a Redis store, or it can be disabled.</p> <p>Multiple worker threads can be used when starting the server.</p>"},{"location":"features/#account-management","title":"Account management","text":"<p>Accounts can be created on the server with which users can perform the following actions, through either a JSON or an HTML API:</p> <ul> <li>Add email/password combinations which can be used to log in.</li> <li>Create pods, which are containers on the server over which the user has full control.</li> <li>Link WebIDs to the account. When using Solid-OIDC,   the user can identify as any of these.   For external WebIDs, the server requires the user to add a triple as identification,   but this can be disabled if needed.</li> <li>Create client credentials, which can be used to authenticate without using the browser.   More information on these can be found here.</li> <li>It is possible to use Solid-OIDC to limit access to certain parts of the account API.   More information on this can be found here.</li> </ul> <p>Using these accounts, the server can generate tokens to support Solid-OIDC authentication.</p>"},{"location":"features/#pods","title":"Pods","text":"<p>The server keeps track of the pod owners, which is a list of WebIDs which have full control access over all resources contained within. Owners can be added to and removed from a pod.</p> <p>Pod URLs can be minted as either subdomain, <code>http://pod.example.com/</code>, or suffix, <code>http://example.com/pod/</code>.</p> <p>When starting the server, a configuration file can be provided to immediately create one or more accounts on the server with their own pods. See the documentation for more information.</p>"},{"location":"features/#notifications","title":"Notifications","text":"<p>CSS supports v0.2.0 of the Solid Notifications Protocol. Specifically it supports the Notification Types WebSocketChannel2023 and WebhookChannel2023.</p> <p>More documentation on notifications can be found here.</p>"},{"location":"architecture/core/","title":"Core building blocks","text":"<p>There are several core building blocks used in many places of the server. These are described here.</p>"},{"location":"architecture/core/#handlers","title":"Handlers","text":"<p>A very important building block that gets reused in many places is the <code>AsyncHandler</code>. The idea is that a handler has 2 important functions. <code>canHandle</code> determines if this class is capable of correctly handling the request, and throws an error if it can not. For example, a class that converts JSON-LD to turtle can handle all requests containing JSON-LD data, but does not know what to do with a request that contains a JPEG. The second function is <code>handle</code> where the class executes on the input data and returns the result. If an error gets thrown here it means there is an issue with the input. For example, if the input data claims to be JSON-LD but is actually not.</p> <p>The power of using this interface really shines when using certain utility classes. The one we use the most is the <code>WaterfallHandler</code>, which takes as input a list of handlers of the same type. The input and output of a <code>WaterfallHandler</code> is the same as those of its inputs, meaning it can be used in the same places. When doing a <code>canHandle</code> call, it will iterate over all its input handlers to find the first one where the <code>canHandle</code> call succeeds, and when calling <code>handle</code> it will return the result of that specific handler. This allows us to chain together many handlers that each have their specific niche, such as handler that each support a specific HTTP method (GET/PUT/POST/etc.), or handlers that only take requests targeting a specific subset of URLs. To the parent class it will look like it has a handler that supports all methods, while in practice it will be a <code>WaterfallHandler</code> containing all these separate handlers.</p> <p>Some other utility classes are the <code>ParallelHandler</code> that runs all handlers simultaneously, and the <code>SequenceHandler</code> that runs all of them one after the other. Since multiple handlers are executed here, these only work for handlers that have no output.</p>"},{"location":"architecture/core/#streams","title":"Streams","text":"<p>Almost all data is handled in a streaming fashion. This allows us to work with very large resources without having to fully load them in memory, a client could be reading data that is being returned by the server while the server is still reading the file. Internally this means we are mostly handling data as <code>Readable</code> objects. We actually use <code>Guarded&lt;Readable&gt;</code> which is an internal format we created to help us with error handling. Such streams can be created using utility functions such as <code>guardStream</code> and <code>guardedStreamFrom</code>. Similarly, we have a <code>pipeSafely</code> to pipe streams in such a way that also helps with errors.</p>"},{"location":"architecture/dependency-injection/","title":"Dependency injection","text":"<p>The community server uses the dependency injection framework Components.js to link all class instances together, and uses Components-Generator.js to automatically generate the necessary description configurations of all classes. This framework allows us to configure our components in a JSON file. The advantage of this is that changing the configuration of components does not require any changes to the code, as one can just change the default configuration file, or provide a custom configuration file.</p> <p>More information can be found in the Components.js documentation, but a summarized overview can be found below.</p>"},{"location":"architecture/dependency-injection/#component-files","title":"Component files","text":"<p>Components.js requires a component file for every class you might want to instantiate. Fortunately those get generated automatically by Components-Generator.js. Calling <code>npm run build</code> will call the generator and generate those JSON-LD files in the <code>dist</code> folder. The generator uses the <code>index.ts</code>, so new classes always have to be added there or they will not get a component file.</p>"},{"location":"architecture/dependency-injection/#configuration-files","title":"Configuration files","text":"<p>Configuration files are how we tell Components.js which classes to instantiate and link together. All the community server configurations can be found in the <code>config</code> folder. That folder also contains information about how different pre-defined configurations can be used.</p> <p>A single component in such a configuration file might look as follows:</p> <pre><code>{\n  \"comment\": \"Storage used for account management.\",\n  \"@id\": \"urn:solid-server:default:AccountStorage\",\n  \"@type\": \"JsonResourceStorage\",\n  \"source\": { \"@id\": \"urn:solid-server:default:ResourceStore\" },\n  \"baseUrl\": { \"@id\": \"urn:solid-server:default:variable:baseUrl\" },\n  \"container\": \"/.internal/accounts/\"\n}\n</code></pre> <p>With the corresponding constructor of the <code>JsonResourceStorage</code> class:</p> <pre><code>public constructor(source: ResourceStore, baseUrl: string, container: string)\n</code></pre> <p>The important elements here are the following:</p> <ul> <li><code>\"comment\"</code>: (optional) A description of this component.</li> <li><code>\"@id\"</code>: (optional) A unique identifier of this component, which allows it to be used as parameter values in     different places.</li> <li><code>\"@type\"</code>: The class name of the component. This must be a TypeScript class name that is exported via <code>index.ts</code>.</li> </ul> <p>As you can see from the constructor, the other fields are direct mappings from the constructor parameters. <code>source</code> references another object, which we refer to using its identifier <code>urn:solid-server:default:ResourceStore</code>. <code>baseUrl</code> is just a string, but here we use a variable that was set before calling Components.js which is why it also references an <code>@id</code>. These variables are set when starting up the server, based on the command line parameters.</p>"},{"location":"architecture/overview/","title":"Architecture overview","text":"<p>The initial architecture document the project was started from can be found here. Many things have been added since the original inception of the project, but the core ideas within that document are still valid.</p> <p>As can be seen from the architecture, an important idea is the modularity of all components. No actual implementations are defined there, only their interfaces. Making all the components independent of each other in such a way provides us with an enormous flexibility: they can all be replaced by a different implementation, without impacting anything else. This is how we can provide many different configurations for the server, and why it is impossible to provide ready solutions for all possible combinations.</p>"},{"location":"architecture/overview/#architecture-diagrams","title":"Architecture diagrams","text":"<p>Having a modular architecture makes it more difficult to give a complete architecture overview. We will limit ourselves to the more commonly used default configurations we provide, and in certain cases we might give examples of what differences there are based on what configurations are being imported.</p> <p>To do this we will make use of architecture diagrams. We will use an example below to explain the formatting used throughout the architecture documentation:</p> <pre><code>flowchart TD\n  LdpHandler(\"&lt;strong&gt;LdpHandler&lt;/strong&gt;&lt;br&gt;ParsingHttphandler\")\n  LdpHandler --&gt; LdpHandlerArgs\n\n  subgraph LdpHandlerArgs[\" \"]\n    RequestParser(\"&lt;strong&gt;RequestParser&lt;/strong&gt;&lt;br&gt;BasicRequestParser\")\n    Auth(\"&lt;br&gt;AuthorizingHttpHandler\")\n    ErrorHandler(\"&lt;strong&gt;ErrorHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ErrorHandler&lt;/&gt;\")\n    ResponseWriter(\"&lt;strong&gt;ResponseWriter&lt;/strong&gt;&lt;br&gt;BasicResponseWriter\")\n  end</code></pre> <p>Below is a summary of how to interpret such diagrams:</p> <ul> <li>Rounded red box: component instantiated in the Components.js configuration.<ul> <li>First line:<ul> <li>Bold text: shorthand of the instance identifier. In case the full URI is not specified,     it can usually be found by prepending <code>urn:solid-server:default:</code> to the shorthand identifier.</li> <li>(empty): this instance has no identifier and is defined in the same place as its parent.</li> </ul> </li> <li>Second line:<ul> <li>Regular text: The class of this instance.</li> <li>Italic text: The interface of this instance.     Will be used if the actual class is not relevant for the explanation or can differ.</li> </ul> </li> </ul> </li> <li>Square grey box: the parameters of the linked instance.</li> <li>Arrow: links an instance to its parameters. Can also be used to indicate the order of parameters if relevant.</li> </ul> <p>For example, in the above, LdpHandler is a shorthand for the actual identifier <code>urn:solid-server:default:LdpHandler</code> and is an instance of <code>ParsingHttpHandler</code>. It has 4 parameters, one of which has no identifier but is an instance of <code>AuthorizingHttpHandler</code>.</p>"},{"location":"architecture/overview/#features","title":"Features","text":"<p>Below are the sections that go deeper into the features of the server and how those work.</p> <ul> <li>How Command Line Arguments are parsed and used</li> <li>How the server is initialized and started</li> <li>How HTTP requests are handled</li> <li>How the server handles a standard Solid request</li> <li>How Notification components are configured</li> </ul>"},{"location":"architecture/features/cli/","title":"Parsing Command line arguments","text":"<p>When starting the server, the application actually uses Components.js twice to instantiate components. The first instantiation is used to parse the command line arguments. These then get converted into Components.js variables and are used to instantiate the actual server.</p>"},{"location":"architecture/features/cli/#architecture","title":"Architecture","text":"<pre><code>flowchart TD\n  CliResolver(\"&lt;strong&gt;CliResolver&lt;/strong&gt;&lt;br&gt;CliResolver\")\n  CliResolver --&gt; CliResolverArgs\n\n  subgraph CliResolverArgs[\" \"]\n    CliExtractor(\"&lt;strong&gt;CliExtractor&lt;/strong&gt;&lt;br&gt;YargsCliExtractor\")\n    ShorthandResolver(\"&lt;strong&gt;ShorthandResolver&lt;/strong&gt;&lt;br&gt;CombinedShorthandResolver\")\n  end\n\n  ShorthandResolver --&gt; ShorthandResolverArgs\n  subgraph ShorthandResolverArgs[\" \"]\n    BaseUrlExtractor(\"&lt;br&gt;BaseUrlExtractor\")\n    KeyExtractor(\"&lt;br&gt;KeyExtractor\")\n    AssetPathExtractor(\"&lt;br&gt;AssetPathExtractor\")\n  end</code></pre> <p>The <code>CliResolver</code> (<code>urn:solid-server-app-setup:default:CliResolver</code>) is simply a way to combine both the <code>CliExtractor</code> (<code>urn:solid-server-app-setup:default:CliExtractor</code>) and <code>ShorthandResolver</code> (<code>urn:solid-server-app-setup:default:ShorthandResolver</code>) into a single object and has no other function.</p> <p>Which arguments are supported and which Components.js variables are generated can depend on the configuration that is being used. For example, for an HTTPS server additional arguments will be needed to specify the necessary key/cert files.</p>"},{"location":"architecture/features/cli/#cliresolver","title":"CliResolver","text":"<p>The <code>CliResolver</code> converts the incoming string of arguments into a key/value object. By default, a <code>YargsCliExtractor</code> is used, which makes use of the <code>yargs</code> library and is configured similarly.</p>"},{"location":"architecture/features/cli/#shorthandresolver","title":"ShorthandResolver","text":"<p>The <code>ShorthandResolver</code> uses the key/value object that was generated above to generate Components.js variable bindings. A <code>CombinedShorthandResolver</code> combines the results of multiple <code>ShorthandExtractor</code> by mapping their values to specific variables. For example, a <code>BaseUrlExtractor</code> will be used to extract the value for <code>baseUrl</code>, or <code>port</code> if no <code>baseUrl</code> value is provided, and use it to generate the value for the variable <code>urn:solid-server:default:variable:baseUrl</code>.</p> <p>These extractors are also where the default values for the server are defined. For example, BaseUrlExtractor will be instantiated with a default port of <code>3000</code> which will be used if no port is provided.</p> <p>The variables generated here will be used to initialize the server.</p>"},{"location":"architecture/features/http-handler/","title":"Handling HTTP requests","text":"<p>The direction of the arrows was changed slightly here to make the graph readable.</p> <pre><code>flowchart LR\n  HttpHandler(\"&lt;strong&gt;HttpHandler&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n  HttpHandler --&gt; HttpHandlerArgs\n\n  subgraph HttpHandlerArgs[\" \"]\n    direction LR\n    Middleware(\"&lt;strong&gt;Middleware&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    WaterfallHandler(\"&lt;br&gt;WaterfallHandler\")\n  end\n\n  Middleware --&gt; WaterfallHandler\n  WaterfallHandler --&gt; WaterfallHandlerArgs\n\n  subgraph WaterfallHandlerArgs[\" \"]\n    direction TB\n    StaticAssetHandler(\"&lt;strong&gt;StaticAssetHandler&lt;/strong&gt;&lt;br&gt;StaticAssetHandler\")\n    OidcHandler(\"&lt;strong&gt;OidcHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    NotificationHttpHandler(\"&lt;strong&gt;NotificationHttpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    StorageDescriptionHandler(\"&lt;strong&gt;StorageDescriptionHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    AuthResourceHttpHandler(\"&lt;strong&gt;AuthResourceHttpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    IdentityProviderHttpHandler(\"&lt;strong&gt;IdentityProviderHttpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n    LdpHandler(\"&lt;strong&gt;LdpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n  end\n\n  StaticAssetHandler --&gt; OidcHandler\n  OidcHandler --&gt; NotificationHttpHandler\n  NotificationHttpHandler --&gt; StorageDescriptionHandler\n  StorageDescriptionHandler --&gt; AuthResourceHttpHandler\n  AuthResourceHttpHandler --&gt; IdentityProviderHttpHandler\n  IdentityProviderHttpHandler --&gt; LdpHandler</code></pre> <p>The <code>HttpHandler</code> is responsible for handling an incoming HTTP request. The request will always first go through the <code>Middleware</code>, where certain required headers will be added such as CORS headers.</p> <p>After that it will go through the list in the <code>WaterfallHandler</code> to find the first handler that understands the request, with the <code>LdpHandler</code> at the bottom being the catch-all default.</p>"},{"location":"architecture/features/http-handler/#staticassethandler","title":"StaticAssetHandler","text":"<p>The <code>urn:solid-server:default:StaticAssetHandler</code> matches exact URLs to static assets which require no further logic. An example of this is the favicon, where the <code>/favicon.ico</code> URL is directed to the favicon file at <code>/templates/images/favicon.ico</code>. It can also map entire folders to a specific path, such as <code>/.well-known/css/styles/</code> which contains all stylesheets.</p>"},{"location":"architecture/features/http-handler/#oidchandler","title":"OidcHandler","text":"<p>The <code>urn:solid-server:default:OidcHandler</code> handles all requests related to the Solid-OIDC specification. The OIDC component is configured to work on the <code>/.oidc/</code> subpath, so this handler catches all those requests and sends them to the internal OIDC library that is used.</p>"},{"location":"architecture/features/http-handler/#notificationhttphandler","title":"NotificationHttpHandler","text":"<p>The <code>urn:solid-server:default:NotificationHttpHandler</code> catches all notification subscription requests. By default these are requests targeting <code>/.notifications/</code>. Which specific subscription type is targeted is then based on the next part of the URL.</p>"},{"location":"architecture/features/http-handler/#storagedescriptionhandler","title":"StorageDescriptionHandler","text":"<p>The <code>urn:solid-server:default:StorageDescriptionHandler</code> returns the relevant RDF data for requests targeting a storage description resource. It does this by knowing which URL suffix is used for such resources, and verifying that the associated container is an actual storage container.</p>"},{"location":"architecture/features/http-handler/#authresourcehttphandler","title":"AuthResourceHttpHandler","text":"<p>The <code>urn:solid-server:default:AuthResourceHttpHandler</code> is identical to the <code>urn:solid-server:default:LdpHandler</code> which will be discussed below, but only handles resources relevant for authorization.</p> <p>In practice this means that if your server is configured to use Web Access Control for authorization, this handler will catch all requests targeting <code>.acl</code> resources.</p> <p>The reason these already need to be handled here is so these can also be used to allow authorization on the following handler(s). More on this can be found in the identity provider documentation</p>"},{"location":"architecture/features/http-handler/#identityproviderhttphandler","title":"IdentityProviderHttpHandler","text":"<p>The <code>urn:solid-server:default:IdentityProviderHttpHandler</code> handles everything related to our custom identity provider API, such as registering, logging in, returning the relevant HTML pages, etc. All these requests are identified by being on the <code>/.account/</code> subpath. More information on the API can be found in the identity provider documentation The architectural overview can be found here.</p>"},{"location":"architecture/features/http-handler/#ldphandler","title":"LdpHandler","text":"<p>Once a request reaches the <code>urn:solid-server:default:LdpHandler</code>, the server assumes this is a standard Solid request according to the Solid protocol. A detailed description of what happens then can be found here</p>"},{"location":"architecture/features/initialization/","title":"Server initialization","text":"<p>When starting the server, multiple Initializers trigger to set up everything correctly, the last one of which starts listening to the specified port. Similarly, when stopping the server several Finalizers trigger to clean up where necessary, although the latter only happens when starting the server through code.</p>"},{"location":"architecture/features/initialization/#app","title":"App","text":"<pre><code>flowchart TD\n  App(\"&lt;strong&gt;App&lt;/strong&gt;&lt;br&gt;App\")\n  App --&gt; AppArgs\n\n  subgraph AppArgs[\" \"]\n    Initializer(\"&lt;strong&gt;Initializer&lt;/strong&gt;&lt;br&gt;&lt;i&gt;Initializer&lt;/i&gt;\")\n    AppFinalizer(\"&lt;strong&gt;Finalizer&lt;/strong&gt;&lt;br&gt;&lt;i&gt;Finalizer&lt;/i&gt;\")\n  end</code></pre> <p><code>App</code> (<code>urn:solid-server:default:App</code>) is the main component that gets instantiated by Components.js. Every other component should be able to trace an instantiation path back to it if it also wants to be instantiated.</p> <p>It's only function is to contain an <code>Initializer</code> and <code>Finalizer</code> which get called by calling <code>start</code>/<code>stop</code> respectively.</p>"},{"location":"architecture/features/initialization/#initializer","title":"Initializer","text":"<pre><code>flowchart TD\n  Initializer(\"&lt;strong&gt;Initializer&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n  Initializer --&gt; InitializerArgs\n\n  subgraph InitializerArgs[\" \"]\n    direction LR\n    LoggerInitializer(\"&lt;strong&gt;LoggerInitializer&lt;/strong&gt;&lt;br&gt;LoggerInitializer\")\n    PrimaryInitializer(\"&lt;strong&gt;PrimaryInitializer&lt;/strong&gt;&lt;br&gt;ProcessHandler\")\n    WorkerInitializer(\"&lt;strong&gt;WorkerInitializer&lt;/strong&gt;&lt;br&gt;ProcessHandler\")\n  end\n\n  LoggerInitializer --&gt; PrimaryInitializer\n  PrimaryInitializer --&gt; WorkerInitializer</code></pre> <p>The very first thing that needs to happen is initializing the logger. Before this other classes will be unable to use logging.</p> <p>The <code>PrimaryInitializer</code> will only trigger once, in the primary worker thread, while the <code>WorkerInitializer</code> will trigger for every worker thread. Although if your server setup is single-threaded, which is the default, there is no relevant difference between those two.</p>"},{"location":"architecture/features/initialization/#primaryinitializer","title":"PrimaryInitializer","text":"<pre><code>flowchart TD\n  PrimaryInitializer(\"&lt;strong&gt;PrimaryInitializer&lt;/strong&gt;&lt;br&gt;ProcessHandler\")\n  PrimaryInitializer --&gt; PrimarySequenceInitializer(\"&lt;strong&gt;PrimarySequenceInitializer&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n  PrimarySequenceInitializer --&gt; PrimarySequenceInitializerArgs\n\n  subgraph PrimarySequenceInitializerArgs[\" \"]\n    direction LR\n    CleanupInitializer(\"&lt;strong&gt;CleanupInitializer&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n    PrimaryParallelInitializer(\"&lt;strong&gt;PrimaryParallelInitializer&lt;/strong&gt;&lt;br&gt;ParallelHandler\")\n    WorkerManager(\"&lt;strong&gt;WorkerManager&lt;/strong&gt;&lt;br&gt;WorkerManager\")\n  end\n\n  CleanupInitializer --&gt; PrimaryParallelInitializer\n  PrimaryParallelInitializer --&gt; WorkerManager</code></pre> <p>The above is a simplification of all the initializers that are present in the <code>PrimaryInitializer</code> as there are several smaller initializers that also trigger but are less relevant here.</p> <p>The <code>CleanupInitializer</code> is an initializer that cleans up anything that might have remained from a previous server start and could impact behaviour. Relevant components in other parts of the configuration are responsible for adding themselves to this array if needed. An example of this is file-based locking components which might need to remove any dangling locking files.</p> <p>The <code>PrimaryParallelInitializer</code> can be used to add any initializers to that have to happen in the primary process. This makes it easier for users to add initializers by being able to append to its handlers.</p> <p>The <code>WorkerManager</code> is responsible for setting up the worker threads, if any.</p>"},{"location":"architecture/features/initialization/#workerinitializer","title":"WorkerInitializer","text":"<pre><code>flowchart TD\n  WorkerInitializer(\"&lt;strong&gt;WorkerInitializer&lt;/strong&gt;&lt;br&gt;ProcessHandler\")\n  WorkerInitializer --&gt; WorkerSequenceInitializer(\"&lt;strong&gt;WorkerSequenceInitializer&lt;/strong&gt;&lt;br&gt;SequenceHandler\")\n  WorkerSequenceInitializer --&gt; WorkerSequenceInitializerArgs\n\n  subgraph WorkerSequenceInitializerArgs[\" \"]\n    direction LR\n    WorkerParallelInitializer(\"&lt;strong&gt;WorkerParallelInitializer&lt;/strong&gt;&lt;br&gt;ParallelHandler\")\n    ServerInitializer(\"&lt;strong&gt;ServerInitializer&lt;/strong&gt;&lt;br&gt;ServerInitializer\")\n  end\n\n  WorkerParallelInitializer --&gt; ServerInitializer</code></pre> <p>The <code>WorkerInitializer</code> is quite similar to the <code>PrimaryInitializer</code> but triggers once per worker thread. Like the <code>PrimaryParallelInitializer</code>, the <code>WorkerParallelInitializer</code> can be used to add any custom initializers that need to run.</p>"},{"location":"architecture/features/initialization/#serverinitializer","title":"ServerInitializer","text":"<p>The <code>ServerInitializer</code> is the initializer that finally starts up the server by listening to the relevant port, once all the initialization described above is finished. To do this it makes use of an <code>HttpServerFactory</code>.</p> <pre><code>flowchart TD\n  ServerInitializer(\"&lt;strong&gt;ServerInitializer&lt;/strong&gt;&lt;br&gt;ServerInitializer\")\n  ServerInitializer --&gt; ServerFactory(\"&lt;strong&gt;ServerFactory&lt;/strong&gt;&lt;br&gt;BaseServerFactory\")\n  ServerFactory --&gt; ServerConfigurator(\"&lt;strong&gt;ServerConfigurator&lt;/strong&gt;&lt;br&gt;ParallelHandler\")\n  ServerConfigurator --&gt; ServerConfiguratorArgs\n\n  subgraph ServerConfiguratorArgs[\" \"]\n    direction LR\n    HandlerServerConfigurator(\"&lt;strong&gt;HandlerServerConfigurator&lt;/strong&gt;&lt;br&gt;HandlerServerConfigurator\")\n    WebSocketServerConfigurator(\"&lt;strong&gt;WebSocketServerConfigurator&lt;/strong&gt;&lt;br&gt;WebSocketServerConfigurator\")\n  end\n\n  HandlerServerConfigurator --&gt; HttpHandler(\"&lt;strong&gt;HttpHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;HttpHandler&lt;/i&gt;\")\n  WebSocketServerConfigurator --&gt; WebSocketHandler(\"&lt;strong&gt;WebSocketHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;WebSocketHandler&lt;/i&gt;\")</code></pre> <p>The <code>HttpServerFactory</code> is responsible for starting a server on a given port. Depending on the configuration this can be an HTTP or an HTTPS server. The created server emits events when it receives requests.</p> <p>Any requests it receives, it sends to its <code>ServerConfigurator</code>, which handles the request as needed. This is a <code>ParallelHandler</code>, supporting two kinds of requests: HTTP requests go through a configurator that sends those to an <code>HttpHandler</code> to resolve HTTP requests. In case WebSockets are enabled to handle notifications, these are handled by the <code>WebSocketHandler</code>.</p>"},{"location":"architecture/features/notifications/","title":"Notifications","text":"<p>This section covers the architecture used to support the Notifications protocol as described in https://solidproject.org/TR/2022/notifications-protocol-20221231.</p> <p>There are three core architectural components, that have distinct entry points:</p> <ul> <li>Exposing metadata to allow discovery of the subscription type.</li> <li>Handling subscriptions targeting a resource.</li> <li>Emitting notifications when there is activity on a resource.</li> </ul>"},{"location":"architecture/features/notifications/#discovery","title":"Discovery","text":"<p>Discovery is done through the storage description resource(s). The server returns the same triples for every such resource as the notification subscription URL is always located in the root of the server.</p> <pre><code>flowchart LR\n  StorageDescriptionHandler(\"&lt;br&gt;StorageDescriptionHandler\")\n  StorageDescriptionHandler --&gt; StorageDescriber(\"&lt;strong&gt;StorageDescriber&lt;/strong&gt;&lt;br&gt;ArrayUnionHandler\")\n  StorageDescriber --&gt; NotificationDescriber(\"NotificationDescriber&lt;br&gt;NotificationDescriber\")\n  NotificationDescriber --&gt; NotificationDescriberArgs\n\n  subgraph NotificationDescriberArgs[\" \"]\n    direction LR\n    NotificationChannelType(\"&lt;br&gt;NotificationChannelType\")\n    NotificationChannelType2(\"&lt;br&gt;NotificationChannelType\")\n  end</code></pre> <p>The server uses a <code>StorageDescriptionHandler</code> to generate the necessary RDF data and to handle content negotiation. To generate the data we have multiple <code>StorageDescriber</code>s, whose results get merged together in an <code>ArrayUnionHandler</code>.</p> <p>A <code>NotificationChannelType</code> contains the specific details of a specification notification channel type, including a JSON-LD representation of the corresponding subscription resource. One specific instance of a <code>StorageDescriber</code> is a <code>NotificationDescriber</code>, which merges those JSON-LD descriptions into a single set of RDF quads. When adding a new subscription type, a new instance of such a class should be added to the <code>urn:solid-server:default:NotificationDescriber</code>.</p>"},{"location":"architecture/features/notifications/#notificationchannel","title":"NotificationChannel","text":"<p>To subscribe, a client has to send a specific JSON-LD request to the URL found during discovery.</p> <pre><code>flowchart LR\n  NotificationTypeHandler(\"&lt;strong&gt;NotificationTypeHandler&lt;/strong&gt;&lt;br&gt;WaterfallHandler\")\n  NotificationTypeHandler --&gt; NotificationTypeHandlerArgs\n\n  subgraph NotificationTypeHandlerArgs[\" \"]\n    direction LR\n    OperationRouterHandler(\"&lt;br&gt;OperationRouterHandler\") --&gt; NotificationSubscriber(\"&lt;br&gt;NotificationSubscriber\")\nNotificationSubscriber --&gt; NotificationChannelType(\"&lt;br&gt;&lt;i&gt;NotificationChannelType&lt;/i&gt;\")\n    OperationRouterHandler2(\"&lt;br&gt;OperationRouterHandler\") --&gt; NotificationSubscriber2(\"&lt;br&gt;NotificationSubscriber\")\nNotificationSubscriber2 --&gt; NotificationChannelType2(\"&lt;br&gt;&lt;i&gt;NotificationChannelType&lt;/i&gt;\")\n  end</code></pre> <p>Every subscription type should have a subscription URL relative to the root notification URL, which in our configs is set to <code>/.notifications/</code>. For every type there is then a <code>OperationRouterHandler</code> that accepts requests to that specific URL, after which a <code>NotificationSubscriber</code> handles all checks related to subscribing, for which it uses a <code>NotificationChannelType</code>. If the subscription is valid and has authorization, the results will be saved in a <code>NotificationChannelStorage</code>.</p>"},{"location":"architecture/features/notifications/#activity","title":"Activity","text":"<pre><code>flowchart TB\n  ListeningActivityHandler(\"&lt;strong&gt;ListeningActivityHandler&lt;/strong&gt;&lt;br&gt;ListeningActivityHandler\")\n  ListeningActivityHandler --&gt; ListeningActivityHandlerArgs\n\n  subgraph ListeningActivityHandlerArgs[\" \"]\n    NotificationChannelStorage(\"&lt;strong&gt;NotificationChannelStorage&lt;/strong&gt;&lt;br&gt;&lt;i&gt;NotificationChannelStorage&lt;/i&gt;\")\n    ResourceStore(\"&lt;strong&gt;ResourceStore&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ActivityEmitter&lt;/i&gt;\")\n    NotificationHandler(\"&lt;strong&gt;NotificationHandler&lt;/strong&gt;&lt;br&gt;WaterfallHandler\")\n  end\n\n  NotificationHandler --&gt; NotificationHandlerArgs\n  subgraph NotificationHandlerArgs[\" \"]\n    direction TB\n    NotificationHandler1(\"&lt;br&gt;&lt;i&gt;NotificationHandler&lt;/i&gt;\")\n    NotificationHandler2(\"&lt;br&gt;&lt;i&gt;NotificationHandler&lt;/i&gt;\")\n  end</code></pre> <p>An <code>ActivityEmitter</code> is a class that emits events every time data changes in the server. The <code>MonitoringStore</code> is an implementation of this in the server. The <code>ListeningActivityHandler</code> is the class that listens to these events and makes sure relevant notifications get sent out.</p> <p>It will pull the relevant subscriptions from the storage and call the stored <code>NotificationHandler</code> for each of time. For every subscription type, a <code>NotificationHandler</code> should be added to the <code>WaterfallHandler</code> that handles notifications for the specific type.</p>"},{"location":"architecture/features/notifications/#websocketchannel2023","title":"WebSocketChannel2023","text":"<p>To add support for WebSocketChannel2023 notifications, components were added as described in the documentation above.</p> <p>For discovery, a <code>NotificationDescriber</code> was added with the corresponding settings.</p> <p>As <code>NotificationChannelType</code>, there is a specific <code>WebSocketChannel2023Type</code> that contains all the necessary information.</p>"},{"location":"architecture/features/notifications/#handling-notifications","title":"Handling notifications","text":"<p>As <code>NotificationHandler</code>, the following architecture is used:</p> <pre><code>flowchart TB\n  TypedNotificationHandler(\"&lt;br&gt;TypedNotificationHandler\")\n  TypedNotificationHandler --&gt; ComposedNotificationHandler(\"&lt;br&gt;ComposedNotificationHandler\")\n  ComposedNotificationHandler --&gt; ComposedNotificationHandlerArgs\n\n  subgraph ComposedNotificationHandlerArgs[\" \"]\n    direction LR\n    BaseNotificationGenerator(\"&lt;strong&gt;BaseNotificationGenerator&lt;/strong&gt;&lt;br&gt;&lt;i&gt;NotificationGenerator&lt;/i&gt;\")\n    BaseNotificationSerializer(\"&lt;strong&gt;BaseNotificationSerializer&lt;/strong&gt;&lt;br&gt;&lt;i&gt;NotificationSerializer&lt;/i&gt;\")\n    WebSocket2023Emitter(\"&lt;strong&gt;WebSocket2023Emitter&lt;/strong&gt;&lt;br&gt;WebSocket2023Emitter\")\n    BaseNotificationGenerator --&gt; BaseNotificationSerializer --&gt; WebSocket2023Emitter\n  end</code></pre> <p>A <code>TypedNotificationHandler</code> is a handler that can be used to filter out subscriptions for a specific type, making sure only WebSocketChannel2023 subscriptions will be handled.</p> <p>A <code>ComposedNotificationHandler</code> combines 3 interfaces to handle the notifications:</p> <ul> <li>A <code>NotificationGenerator</code> converts the information into a Notification object.</li> <li>A <code>NotificationSerializer</code> converts a Notification object into a serialized Representation.</li> <li>A <code>NotificationEmitter</code> takes a Representation and sends it out in a way specific to that subscription type.</li> </ul> <p><code>urn:solid-server:default:BaseNotificationGenerator</code> is a generator that fills in the default Notification template, and also caches the result so it can be reused by multiple subscriptions.</p> <p><code>urn:solid-server:default:BaseNotificationSerializer</code> converts the Notification to a JSON-LD representation and handles any necessary content negotiation based on the <code>accept</code> notification feature.</p> <p>A <code>WebSocket2023Emitter</code> is a specific emitter that checks whether the current open WebSockets correspond to the subscription.</p>"},{"location":"architecture/features/notifications/#websockets","title":"WebSockets","text":"<pre><code>flowchart TB\n  WebSocket2023Listener(\"&lt;strong&gt;WebSocket2023Listener&lt;/strong&gt;&lt;br&gt;WebSocket2023Listener\")\n  WebSocket2023Listener --&gt; WebSocket2023ListenerArgs\n\n  subgraph WebSocket2023ListenerArgs[\" \"]\n    direction LR\n    NotificationChannelStorage(\"&lt;strong&gt;NotificationChannelStorage&lt;/strong&gt;&lt;br&gt;NotificationChannelStorage\")\n    SequenceHandler(\"&lt;br&gt;SequenceHandler\")\n  end\n\n  SequenceHandler --&gt; SequenceHandlerArgs\n\n  subgraph SequenceHandlerArgs[\" \"]\n    direction TB\n    WebSocket2023Storer(\"&lt;strong&gt;WebSocket2023Storer&lt;/strong&gt;&lt;br&gt;WebSocket2023Storer\")\n    WebSocket2023StateHandler(\"&lt;strong&gt;WebSocket2023StateHandler&lt;/strong&gt;&lt;br&gt;BaseStateHandler\")\n  end</code></pre> <p>To detect and store WebSocket connections, the <code>WebSocket2023Listener</code> is added as a listener to the HTTP server. For all WebSocket connections that get opened, it verifies whether they correspond to an existing subscription. If yes, the information gets sent out to its stored <code>WebSocket2023Handler</code>.</p> <p>In this case, this is a <code>SequenceHandler</code>, which contains a <code>WebSocket2023Storer</code> and a <code>BaseStateHandler</code>. The <code>WebSocket2023Storer</code> will store the WebSocket in the same map used by the <code>WebSocket2023Emitter</code>, so that class can emit events later on, as mentioned above. The state handler will make sure that a notification gets sent out if the subscription has a <code>state</code> feature request, as defined in the notification specification.</p>"},{"location":"architecture/features/notifications/#webhookchannel2023","title":"WebhookChannel2023","text":"<p>The additions required to support WebhookChannel2023 are quite similar to those needed for WebSocketChannel2023:</p> <ul> <li>For discovery, there is a <code>WebhookDescriber</code>, which is an extension of a <code>NotificationDescriber</code>.</li> <li>The <code>WebhookChannel2023Type</code> class contains all the necessary typing information.</li> <li><code>WebhookEmitter</code> is the <code>NotificationEmitter</code> that sends the request.</li> <li><code>WebhookUnsubscriber</code> and <code>WebhookWebId</code> are additional utility classes to support the spec requirements.</li> </ul>"},{"location":"architecture/features/notifications/#streaminghttpchannel2023","title":"StreamingHTTPChannel2023","text":"<p>Currently, support for StreamingHTTPChannel2023 only covers default, pre-established channels made available for every resource. Those channels output <code>text/turtle</code>.</p> <p>Support for custom, subscription-based channels can be added in the future.</p> <ul> <li>For discovery, there is a <code>StreamingHttpMetadataWriter</code>, which adds <code>Link</code> to every <code>HTTP</code> response header using <code>rel=\"http://www.w3.org/ns/solid/terms#updatesViaStreamingHttp2023\"</code>. It links directly to the <code>receiveFrom</code> endpoint of the default, pre-established channel for that topic resource.</li> <li>Requests to <code>receiveFrom</code> endpoints are handled by a <code>StreamingHttpRequestHandler</code>.<ul> <li>It performs an authorization check.</li> <li>It creates a new response stream and adds it to the <code>StreamingHttpMap</code>, indexed by the topic resource.</li> <li>It sends an initial notification, similar to notification channels using a <code>state</code> feature.</li> </ul> </li> <li><code>StreamingHttp2023Emitter</code> is the <code>NotificationEmitter</code> that writes notifications to matching response streams.</li> <li><code>StreamingHttpListeningActivityHandler</code> is responsible for observing the <code>MonitoringStore</code>   and emitting notifications when needed.   It doesn't use a <code>NotificationChannelStorage</code> since the default, pre-established channels are not   subscription-based. Instead, it uses a <code>StreamingHttpMap</code> to check for active receivers.</li> </ul> <pre><code>flowchart TB\n  StreamingHttpListeningActivityHandler(\"&lt;strong&gt;StreamingHttpListeningActivityHandler&lt;/strong&gt;&lt;br&gt;StreamingHttpListeningActivityHandler\")\n  StreamingHttpListeningActivityHandler --&gt; StreamingHttpListeningActivityHandlerArgs\n\n  subgraph StreamingHttpListeningActivityHandlerArgs[\" \"]\n    StreamingHttpMap(\"&lt;strong&gt;StreamingHttpMap&lt;/strong&gt;&lt;br&gt;&lt;i&gt;StreamingHttpMap&lt;/i&gt;\")\n    ResourceStore(\"&lt;strong&gt;ResourceStore&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ActivityEmitter&lt;/i&gt;\")\n    StreamingHttpNotificationHandler(\"&lt;strong&gt;StreamingHttpNotificationHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ComposedNotificationHandler&lt;/i&gt;\")\n  end\n\n   StreamingHttpNotificationHandler --&gt; StreamingHttpNotificationHandlerArgs\n  subgraph StreamingHttpNotificationHandlerArgs[\" \"]\n    direction TB\n    Generator(\"&lt;strong&gt;BaseNotificationGenerator&lt;/strong&gt;\")\n    Serializer(\"&lt;strong&gt;BaseNotificationSerializer&lt;/strong&gt;\")\n    Emitter(\"&lt;strong&gt;StreamingHttp2023Emitter&lt;/strong&gt;&lt;br&gt;&lt;i&gt;StreamingHttp2023Emitter&lt;/i&gt;\")\n    ETagHandler(\"&lt;strong&gt;ETagHandler&lt;/strong&gt;\")\n\n  end</code></pre>"},{"location":"architecture/features/accounts/controls/","title":"JSON API controls","text":"<p>A large part of every response of the JSON API is the <code>controls</code> block. These are generated by using nested <code>ControlHandler</code> objects. These take as input a key/value with the values being either routes or other interaction handlers. These will then be executed to determine the values of the output JSON object, with the same keys. By using other <code>ControlHandler</code>s in the input map, we can create nested objects.</p> <p>The default structure of these handlers is as follows:</p> <pre><code>flowchart LR\n  RootControlHandler(\"&lt;strong&gt;RootControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n  RootControlHandler --controls--&gt; ControlHandler(\"&lt;strong&gt;ControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n  ControlHandler --main--&gt; MainControlHandler(\"&lt;strong&gt;MainControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n  ControlHandler --account--&gt; AccountControlHandler(\"&lt;strong&gt;AccountControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n  ControlHandler --password--&gt; PasswordControlHandler(\"&lt;strong&gt;PasswordControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n  ControlHandler --\"oidc\"--&gt; OidcControlHandler(\"&lt;strong&gt;OidcControlHandler&lt;/strong&gt;&lt;br&gt;OidcControlHandler\")\n  ControlHandler --html--&gt; HtmlControlHandler(\"&lt;strong&gt;HtmlControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n\n  HtmlControlHandler --main--&gt; MainHtmlControlHandler(\"&lt;strong&gt;MainHtmlControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n  HtmlControlHandler --account--&gt; AccountHtmlControlHandler(\"&lt;strong&gt;AccountHtmlControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n  HtmlControlHandler --password--&gt; PasswordHtmlControlHandler(\"&lt;strong&gt;PasswordHtmlControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")</code></pre> <p>Each of these control handlers then has a map of routes which link to the actual API endpoints. How to add these can be seen here.</p>"},{"location":"architecture/features/accounts/overview/","title":"Account management","text":"<p>The main entry point is the <code>IdentityProviderHandler</code>, which routes all requests targeting a resource starting with <code>/.account/</code> into this handler, after which it goes through similar parsing handlers as described here, the flow of which is shown below:</p> <pre><code>flowchart LR\n  Handler(\"&lt;strong&gt;IdentityProviderHandler&lt;/strong&gt;&lt;br&gt;RouterHandler\")\n  ParsingHandler(\"&lt;strong&gt;IdentityProviderParsingHandler&lt;/strong&gt;&lt;br&gt;AuthorizingHttpHandler\")\n  AuthorizingHandler(\"&lt;strong&gt;IdentityProviderAuthorizingHandler&lt;/strong&gt;&lt;br&gt;AuthorizingHttpHandler\")\n\n  Handler --&gt; ParsingHandler\n  ParsingHandler --&gt; AuthorizingHandler\n  AuthorizingHandler --&gt; HttpHandler(\"&lt;strong&gt;IdentityProviderHttpHandler&lt;/strong&gt;&lt;br&gt;IdentityProviderHttpHandler\")</code></pre> <p>The <code>IdentityProviderHttpHandler</code> is where the actual differentiation of this component starts. It handles identifying the account based on the supplied cookie and determining the active OIDC interaction, after which it calls an <code>InteractionHandler</code> with this additional input. The <code>InteractionHandler</code> is many handlers chained together as follows:</p> <pre><code>flowchart TD\n  HttpHandler(\"&lt;strong&gt;IdentityProviderHttpHandler&lt;/strong&gt;&lt;br&gt;IdentityProviderHttpHandler\")\n  HttpHandler --&gt; InteractionHandler(\"&lt;strong&gt;InteractionHandler&lt;/strong&gt;&lt;br&gt;WaterfallHandler\")\n  InteractionHandler --&gt; InteractionHandlerArgs\n\n  subgraph InteractionHandlerArgs[\" \"]\n    HtmlViewHandler(\"&lt;strong&gt;HtmlViewHandler&lt;/strong&gt;&lt;br&gt;HtmlViewHandler\")\n    LockingInteractionHandler(\"&lt;strong&gt;LockingInteractionHandler&lt;/strong&gt;&lt;br&gt;LockingInteractionHandler\")\n  end\n\n  LockingInteractionHandler --&gt; JsonConversionHandler(\"&lt;strong&gt;JsonConversionHandler&lt;/strong&gt;&lt;br&gt;JsonConversionHandler\")\n  JsonConversionHandler --&gt; VersionHandler(\"&lt;strong&gt;VersionHandler&lt;/strong&gt;&lt;br&gt;VersionHandler\")\n  VersionHandler --&gt; CookieInteractionHandler(\"&lt;strong&gt;CookieInteractionHandler&lt;/strong&gt;&lt;br&gt;CookieInteractionHandler\")\n  CookieInteractionHandler --&gt; RootControlHandler(\"&lt;strong&gt;RootControlHandler&lt;/strong&gt;&lt;br&gt;ControlHandler\")\n  RootControlHandler --&gt; LocationInteractionHandler(\"&lt;strong&gt;LocationInteractionHandler&lt;/strong&gt;&lt;br&gt;LocationInteractionHandler\")\n  LocationInteractionHandler --&gt; InteractionRouteHandler(\"&lt;strong&gt;InteractionRouteHandler&lt;/strong&gt;&lt;br&gt;WaterfallHandler\")</code></pre> <p>The <code>HtmlViewHandler</code> catches all request that request an HTML output. This class keeps a list of HTML pages and their corresponding URL and returns them when needed.</p> <p>If the request is for the JSON API, the request goes through a chain of handlers, each responsible for a specific step in the API process. We'll list and summarize these here:</p> <ul> <li><code>LockingInteractionHandler</code>: In case the request is authenticated,   this requests a lock on that account to prevent simultaneous operations on the same account.</li> <li><code>JsonConversionHandler</code>: Converts the streaming input into a JSON object.</li> <li><code>VersionHandler</code>: Adds a version number to all output.</li> <li><code>CookieInteractionHandler</code>: Refreshes the cookie if necessary and adds relevant cookie metadata to the output.</li> <li><code>RootControlHandler</code>: Responsible for adding all the controls to the output.   Will take as input multiple other control handlers which create the nested values in the <code>controls</code> field.</li> <li><code>LocationInteractionHandler</code>: Catches redirect errors and converts them to JSON objects with a <code>location</code> field.</li> <li><code>InteractionRouteHandler</code>: A <code>WaterfallHandler</code> containing an entry for every supported API route.</li> </ul>"},{"location":"architecture/features/accounts/routes/","title":"Account API routes","text":"<p>All entries contained in the <code>urn:solid-server:default:InteractionRouteHandler</code> have a similar structure: an <code>InteractionRouteHandler</code>, or <code>AuthorizedRouteHandler</code> for authenticated requests, which checks if the request targets a specific URL and redirects the request to its source if there is a match. Its source is quite often a <code>ViewInteractionHandler</code>, which returns a specific view on GET requests and performs an operation on POST requests, but other handlers can also occur.</p> <p>Below we will give an example of one API route and all the components that are necessary to add it to the server.</p>"},{"location":"architecture/features/accounts/routes/#route-handler","title":"Route handler","text":"<pre><code>{\n  \"@id\": \"urn:solid-server:default:AccountWebIdRouter\",\n  \"@type\": \"AuthorizedRouteHandler\",\n  \"route\": {\n    \"@id\": \"urn:solid-server:default:AccountWebIdRoute\",\n    \"@type\": \"RelativePathInteractionRoute\",\n    \"base\": { \"@id\": \"urn:solid-server:default:AccountIdRoute\" },\n    \"relativePath\": \"webid/\"\n  },\n  \"source\": { \"@id\": \"urn:solid-server:default:WebIdHandler\" }\n}\n</code></pre> <p>The main entry point is the route handler, which determines the URL necessary to reach this API. In this case we create a new route, relative to the <code>urn:solid-server:default:AccountIdRoute</code>. That route specifically matches URLs of the format <code>http://localhost:3000/.account/account/&lt;accountId&gt;/</code>. Here we create a route relative to that one by appending <code>webid</code>, so the resulting route would match <code>http://localhost:3000/.account/account/&lt;accountId&gt;/webid/</code>. Since an <code>AuthorizedRouteHandler</code> is used here, the request also needs to be authenticated using an account cookie. If there is match, the request will be sent to the <code>urn:solid-server:default:WebIdHandler</code>.</p>"},{"location":"architecture/features/accounts/routes/#interaction-handler","title":"Interaction handler","text":"<pre><code>{\n  \"@id\": \"urn:solid-server:default:WebIdHandler\",\n  \"@type\": \"ViewInteractionHandler\",\n  \"source\": {\n    \"@id\": \"urn:solid-server:default:LinkWebIdHandler\",\n    \"@type\": \"LinkWebIdHandler\",\n    \"baseUrl\": { \"@id\": \"urn:solid-server:default:variable:baseUrl\" },\n    \"ownershipValidator\": { \"@id\": \"urn:solid-server:default:OwnershipValidator\" },\n    \"accountStore\": { \"@id\": \"urn:solid-server:default:AccountStore\" },\n    \"webIdStore\": { \"@id\": \"urn:solid-server:default:WebIdStore\" },\n    \"identifierStrategy\": { \"@id\": \"urn:solid-server:default:IdentifierStrategy\" }\n  }\n}\n</code></pre> <p>The interaction handler is the class that performs the necessary operation based on the request. Often these are wrapped in a <code>ViewInteractionHandler</code>, which allows classes to have different support for GET and POST requests.</p>"},{"location":"architecture/features/accounts/routes/#exposing-the-api","title":"Exposing the API","text":"<pre><code>{\n  \"@id\": \"urn:solid-server:default:InteractionRouteHandler\",\n  \"@type\": \"WaterfallHandler\",\n  \"handlers\": [\n    { \"@id\": \"urn:solid-server:default:AccountWebIdRouter\" }\n  ]\n}\n</code></pre> <p>To make sure the API can be accessed, it needs to be added to the list of <code>urn:solid-server:default:InteractionRouteHandler</code>. This is the main handler that contains entries for all the APIs. This block of Components.js adds the route handler defined above to that list.</p>"},{"location":"architecture/features/accounts/routes/#adding-the-necessary-controls","title":"Adding the necessary controls","text":"<pre><code>{\n  \"@id\": \"urn:solid-server:default:AccountControlHandler\",\n  \"@type\": \"ControlHandler\",\n  \"controls\": [{\n    \"ControlHandler:_controls_key\": \"webId\",\n    \"ControlHandler:_controls_value\": { \"@id\": \"urn:solid-server:default:AccountWebIdRoute\" }\n  }]\n}\n</code></pre> <p>To make sure people can find the API, it is necessary to link it through the associated <code>controls</code> object. This API is related to account management, so we add its route in the account controls with the key <code>webId</code>. More information about controls can be found here.</p>"},{"location":"architecture/features/accounts/routes/#adding-html","title":"Adding HTML","text":"<pre><code>{\n  \"@id\": \"urn:solid-server:default:HtmlViewHandler\",\n  \"@type\": \"HtmlViewHandler\",\n  \"templates\": [{\n    \"@id\": \"urn:solid-server:default:LinkWebIdHtml\",\n    \"@type\": \"HtmlViewEntry\",\n    \"filePath\": \"@css:templates/identity/account/link-webid.html.ejs\",\n    \"route\": { \"@id\": \"urn:solid-server:default:AccountWebIdRoute\" }\n  }]\n}\n</code></pre> <p>Some API routes also have an associated HTML page, in which case the page needs to be added to the <code>urn:solid-server:default:HtmlViewHandler</code>, which is what we do here. Usually you will also want to add HTML controls so the page can be found.</p> <pre><code>{\n  \"@id\": \"urn:solid-server:default:AccountHtmlControlHandler\",\n  \"@type\": \"ControlHandler\",\n  \"controls\": [{\n    \"ControlHandler:_controls_key\": \"linkWebId\",\n    \"ControlHandler:_controls_value\": { \"@id\": \"urn:solid-server:default:AccountWebIdRoute\" }\n  }]\n}\n</code></pre>"},{"location":"architecture/features/protocol/authorization/","title":"Authorization","text":"<pre><code>flowchart TD\n  AuthorizingHttpHandler(\"&lt;br&gt;AuthorizingHttpHandler\")\n  AuthorizingHttpHandler --&gt; AuthorizingHttpHandlerArgs\n\n  subgraph AuthorizingHttpHandlerArgs[\" \"]\n    CredentialsExtractor(\"&lt;strong&gt;CredentialsExtractor&lt;/strong&gt;&lt;br&gt;&lt;i&gt;CredentialsExtractor&lt;/i&gt;\")\n    ModesExtractor(\"&lt;strong&gt;ModesExtractor&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ModesExtractor&lt;/i&gt;\")\n    PermissionReader(\"&lt;strong&gt;PermissionReader&lt;/strong&gt;&lt;br&gt;&lt;i&gt;PermissionReader&lt;/i&gt;\")\n    Authorizer(\"&lt;strong&gt;Authorizer&lt;/strong&gt;&lt;br&gt;PermissionBasedAuthorizer\")\n    OperationHttpHandler(\"&lt;br&gt;&lt;i&gt;OperationHttpHandler&lt;/i&gt;\")\n  end</code></pre> <p>Authorization is usually handled by the <code>AuthorizingHttpHandler</code>, which receives a parsed HTTP request in the form of an <code>Operation</code>. It goes through the following steps:</p> <ol> <li>A <code>CredentialsExtractor</code> identifies the credentials of the agent making the call.</li> <li>A <code>ModesExtractor</code> finds which access modes are needed for which resources.</li> <li>A <code>PermissionReader</code> determines the permissions the agent has on the targeted resources.</li> <li>The above results are compared in an <code>Authorizer</code>.</li> <li>If the request is allowed, call the <code>OperationHttpHandler</code>, otherwise throw an error.</li> </ol>"},{"location":"architecture/features/protocol/authorization/#authentication","title":"Authentication","text":"<p>There are multiple <code>CredentialsExtractor</code>s that each determine identity in a different way. Potentially multiple extractors can apply, making a requesting agent have multiple credentials.</p> <p>The diagram below shows the default configuration if authentication is enabled.</p> <pre><code>flowchart TD\n  CredentialsExtractor(\"&lt;strong&gt;CredentialsExtractor&lt;/strong&gt;&lt;br&gt;UnionCredentialsExtractor\")\n  CredentialsExtractor --&gt; CredentialsExtractorArgs\n\n  subgraph CredentialsExtractorArgs[\" \"]\n    WaterfallHandler(\"&lt;br&gt;WaterfallHandler\")\n    PublicCredentialsExtractor(\"&lt;br&gt;PublicCredentialsExtractor\")\n  end\n\n  WaterfallHandler --&gt; WaterfallHandlerArgs\n  subgraph WaterfallHandlerArgs[\" \"]\n    direction LR\n    DPoPWebIdExtractor(\"&lt;br&gt;DPoPWebIdExtractor\") --&gt; BearerWebIdExtractor(\"&lt;br&gt;BearerWebIdExtractor\")\n  end</code></pre> <p>Both of the WebID extractors make use of the <code>access-token-verifier</code> library to parse incoming tokens based on the Solid-OIDC specification. All these credentials then get combined into a single union object.</p> <p>If successful, a <code>CredentialsExtractor</code> will return an object containing all the information extracted, such as the WebID of the agent, or the issuer of the token.</p> <p>There are also debug configuration options available that can be used to simulate credentials. These can be enabled as different options through the <code>config/ldp/authentication</code> imports.</p>"},{"location":"architecture/features/protocol/authorization/#modes-extraction","title":"Modes extraction","text":"<p>Access modes are a predefined list of <code>read</code>, <code>write</code>, <code>append</code>, <code>create</code> and <code>delete</code>. The <code>ModesExtractor</code> determine which modes will be necessary and for which resources, based on the request contents.</p> <pre><code>flowchart TD\n  ModesExtractor(\"&lt;strong&gt;ModesExtractor&lt;/strong&gt;&lt;br&gt;IntermediateCreateExtractor\")\n  ModesExtractor --&gt; HttpModesExtractor(\"&lt;strong&gt;HttpModesExtractor&lt;/strong&gt;&lt;br&gt;WaterfallHandler\")\n\n  HttpModesExtractor --&gt; HttpModesExtractorArgs\n\n  subgraph HttpModesExtractorArgs[\" \"]\n    direction LR\n    PatchModesExtractor(\"&lt;strong&gt;PatchModesExtractor&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ModesExtractor&lt;/i&gt;\") --&gt; MethodModesExtractor(\"&lt;br&gt;MethodModesExtractor\")\n  end</code></pre> <p>The <code>IntermediateCreateExtractor</code> is responsible if requests try to create intermediate containers with a single request. E.g., a PUT request to <code>/foo/bar/baz</code> should create both the <code>/foo/</code> and <code>/foo/bar/</code> containers in case they do not exist yet. This extractor makes sure that <code>create</code> permissions are also checked on those containers.</p> <p>Modes can usually be determined based on just the HTTP methods, which is what the <code>MethodModesExtractor</code> does. A GET request will always need the <code>read</code> mode for example.</p> <p>The only exception are PATCH requests, where the necessary modes depend on the body and the PATCH type.</p> <pre><code>flowchart TD\n  PatchModesExtractor(\"&lt;strong&gt;PatchModesExtractor&lt;/strong&gt;&lt;br&gt;WaterfallHandler\") --&gt; PatchModesExtractorArgs\n  subgraph PatchModesExtractorArgs[\" \"]\n    N3PatchModesExtractor(\"&lt;br&gt;N3PatchModesExtractor\")\n    SparqlUpdateModesExtractor(\"&lt;br&gt;SparqlUpdateModesExtractor\")\n  end</code></pre> <p>The server supports both N3 Patch and SPARQL Update PATCH requests. In both cases it will parse the bodies to determine what the impact would be of the request and what modes it requires.</p>"},{"location":"architecture/features/protocol/authorization/#permission-reading","title":"Permission reading","text":"<p><code>PermissionReader</code>s take the input of the above to determine which permissions are available. The modes from the previous step are not yet needed, but can be used as optimization as we only need to know if we have permission on those modes. Each reader returns all the information it can find based on the resources and modes it receives. In most of the default configuration the following readers are combined when WebACL is enabled as authorization method. In case authorization is disabled by changing the authorization import to <code>config/ldp/authorization/allow-all.json</code>, the diagram would be a single class that always returns all permissions.</p> <pre><code>flowchart TD\n  PermissionReader(\"&lt;strong&gt;PermissionReader&lt;/strong&gt;&lt;br&gt;AuxiliaryReader\")\n  PermissionReader --&gt; UnionPermissionReader(\"&lt;br&gt;UnionPermissionReader\")\n  UnionPermissionReader --&gt; UnionPermissionReaderArgs\n\n  subgraph UnionPermissionReaderArgs[\" \"]\n    PathBasedReader(\"&lt;strong&gt;PathBasedReader&lt;/strong&gt;&lt;br&gt;PathBasedReader\")\n    OwnerPermissionReader(\"&lt;strong&gt;OwnerPermissionReader&lt;/strong&gt;&lt;br&gt;OwnerPermissionReader\")\n    WrappedWebAclReader(\"&lt;strong&gt;WrappedWebAclReader&lt;/strong&gt;&lt;br&gt;ParentContainerReader\")\n  end\n\n  WrappedWebAclReader --&gt; WebAclAuxiliaryReader(\"&lt;strong&gt;WebAclAuxiliaryReader&lt;/strong&gt;&lt;br&gt;AuthAuxiliaryReader\")\n  WebAclAuxiliaryReader --&gt; WebAclReader(\"&lt;strong&gt;WebAclReader&lt;/strong&gt;&lt;br&gt;WebAclReader\")</code></pre> <p>The first thing that happens is that if the target is an auxiliary resource that uses the authorization of its subject resource, the <code>AuxiliaryReader</code> inserts that identifier instead. An example of this is if the requests targets the metadata of a resource.</p> <p>The <code>UnionPermissionReader</code> then combines the results of its readers into a single permission object. If one reader rejects a specific mode and another allows it, the rejection takes priority.</p> <p>The <code>PathBasedReader</code> rejects all permissions for certain paths. This is used to prevent access to the internal data of the server.</p> <p>The <code>OwnerPermissionReader</code> makes sure owners always have control access to the pods they created on the server. Users will always be able to modify the ACL resources in their pod, even if they accidentally removed their own access.</p> <p>The final readers are specifically relevant for the WebACL algorithm. The <code>ParentContainerReader</code> checks the permissions on a parent resource if required: creating a resource requires <code>append</code> permissions on the parent container, while deleting a resource requires <code>write</code> permissions there.</p> <p>In case the target is an ACL resource, <code>control</code> permissions need to be checked, no matter what mode was generated by the <code>ModesExtractor</code>. The <code>AuthAuxiliaryReader</code> makes sure this conversion happens.</p> <p>Finally, the <code>WebAclReader</code> implements the efffective ACL resource algorithm and returns the permissions it finds in that resource. In case no ACL resource is found this indicates a configuration error and no permissions will be granted.</p>"},{"location":"architecture/features/protocol/authorization/#acp","title":"ACP","text":"<p>It is also possible to use ACP as authorization method instead of WebACL. In that case the diagram is very similar, except the <code>AuthAuxiliaryReader</code> is configured for Access Control Resources, and it points to a <code>AcpReader</code> instead.</p>"},{"location":"architecture/features/protocol/authorization/#authorization_1","title":"Authorization","text":"<p>All the results of the previous steps then get combined in the <code>PermissionBasedAuthorizer</code> to either allow or reject a request. If no permissions are found for a requested mode, or they are explicitly forbidden, a 401/403 will be returned, depending on if the agent was logged in or not.</p>"},{"location":"architecture/features/protocol/overview/","title":"Solid protocol","text":"<p>The <code>LdpHandler</code>, named as a reference to the Linked Data Platform specification, chains several handlers together, each with their own specific purpose, to fully resolve the HTTP request. It specifically handles Solid requests as described in the protocol specification, e.g. a POST request to create a new resource.</p> <p>Below is a simplified view of how these handlers are linked.</p> <pre><code>flowchart LR\n  LdpHandler(\"&lt;strong&gt;LdpHandler&lt;/strong&gt;&lt;br&gt;ParsingHttpHandler\")\n  LdpHandler --&gt; AuthorizingHttpHandler(\"&lt;br&gt;AuthorizingHttpHandler\")\n  AuthorizingHttpHandler --&gt; OperationHandler(\"&lt;strong&gt;OperationHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;OperationHandler&lt;/i&gt;\")\n  OperationHandler --&gt; ResourceStore(\"&lt;strong&gt;ResourceStore&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ResourceStore&lt;/i&gt;\")</code></pre> <p>A standard request would go through the following steps:</p> <ol> <li>The <code>ParsingHttphandler</code> parses the HTTP request into a manageable format, both body and metadata such as headers.</li> <li>The <code>AuthorizingHttpHandler</code> verifies if the request is authorized to access the targeted resource.</li> <li>The <code>OperationHandler</code> determines which action is required based on the HTTP method.</li> <li>The <code>ResourceStore</code> does all the relevant data work.</li> <li>The <code>ParsingHttphandler</code> eventually receives the response data, or an error, and handles the output.</li> </ol> <p>Below are sections that go deeper into the specific steps.</p> <ul> <li>How input gets parsed and output gets returned</li> <li>How authentication and authorization work</li> <li>What the <code>ResourceStore</code> looks like</li> <li>How resources can be modified</li> </ul>"},{"location":"architecture/features/protocol/parsing/","title":"Parsing and responding to HTTP requests","text":"<pre><code>flowchart TD\n  ParsingHttphandler(\"&lt;br&gt;ParsingHttphandler\")\n  ParsingHttphandler --&gt; ParsingHttphandlerArgs\n\n  subgraph ParsingHttphandlerArgs[\" \"]\n    RequestParser(\"&lt;strong&gt;RequestParser&lt;/strong&gt;&lt;br&gt;BasicRequestParser\")\n    AuthorizingHttpHandler(\"&lt;strong&gt;&lt;/strong&gt;&lt;br&gt;AuthorizingHttpHandler\")\n    ErrorHandler(\"&lt;strong&gt;ErrorHandler&lt;/strong&gt;&lt;br&gt;&lt;i&gt;ErrorHandler&lt;/i&gt;\")\n    ResponseWriter(\"&lt;strong&gt;ResponseWriter&lt;/strong&gt;&lt;br&gt;BasicResponseWriter\")\n  end</code></pre> <p>A <code>ParsingHttpHandler</code> handles both the parsing of the input data, and the serializing of the output data. It follows these 3 steps:</p> <ol> <li>Use the <code>RequestParser</code> to convert the incoming data into an <code>Operation</code>.</li> <li>Send the <code>Operation</code> to the <code>AuthorizingHttpHandler</code> to receive either a <code>Representation</code> if the operation was a success,     or an <code>Error</code> in case something went wrong.<ul> <li>In case of an error the <code>ErrorHandler</code> will convert the <code>Error</code> into a <code>ResponseDescription</code>.</li> </ul> </li> <li>Use the <code>ResponseWriter</code> to output the <code>ResponseDescription</code> as an HTTP response.</li> </ol>"},{"location":"architecture/features/protocol/parsing/#parsing-the-request","title":"Parsing the request","text":"<pre><code>flowchart TD\n  RequestParser(\"&lt;strong&gt;RequestParser&lt;/strong&gt;&lt;br&gt;BasicRequestParser\") --&gt; RequestParserArgs\n  subgraph RequestParserArgs[\" \"]\n    TargetExtractor(\"&lt;strong&gt;TargetExtractor&lt;/strong&gt;&lt;br&gt;OriginalUrlExtractor\")\n    PreferenceParser(\"&lt;strong&gt;PreferenceParser&lt;/strong&gt;&lt;br&gt;AcceptPreferenceParser\")\n    MetadataParser(\"&lt;strong&gt;MetadataParser&lt;/strong&gt;&lt;br&gt;&lt;i&gt;MetadataParser&lt;/i&gt;\")\n    BodyParser(\"&lt;br&gt;&lt;i&gt;Bodyparser&lt;/i&gt;\")\n    Conditions(\"&lt;br&gt;BasicConditionsParser\")\n  end\n\n  OriginalUrlExtractor --&gt; IdentifierStrategy(\"&lt;strong&gt;IdentifierStrategy&lt;/strong&gt;&lt;br&gt;&lt;i&gt;IdentifierStrategy&lt;/i&gt;\")</code></pre> <p>The <code>BasicRequestParser</code> is mostly an aggregator of multiple smaller parsers that each handle a very specific part.</p>"},{"location":"architecture/features/protocol/parsing/#url","title":"URL","text":"<p>This is a single class, the <code>OriginalUrlExtractor</code>, but fulfills the very important role of making sure input URLs are handled consistently.</p> <p>The query parameters will always be completely removed from the URL.</p> <p>There is also an algorithm to make sure all URLs have a \"canonical\" version as for example both <code>&amp;</code> and <code>%26</code> can be interpreted in the same way. Specifically all special characters will be encoded into their percent encoding.</p> <p>The <code>IdentifierStrategy</code> it gets as input is used to determine if the resulting URL is within the scope of the server. This can differ depending on if the server uses subdomains or not.</p> <p>The resulting identifier will be stored in the <code>target</code> field of an <code>Operation</code> object.</p>"},{"location":"architecture/features/protocol/parsing/#preferences","title":"Preferences","text":"<p>The <code>AcceptPreferenceParser</code> parses the <code>Accept</code> header and all the relevant <code>Accept-*</code> headers. These will all be put into the <code>preferences</code> field of an <code>Operation</code> object. These will later be used to handle the content negotiation.</p> <p>For example, when sending an <code>Accept: text/turtle; q=0.9</code> header, this wil result in the preferences object <code>{ type: { 'text/turtle': 0.9 } }</code>.</p>"},{"location":"architecture/features/protocol/parsing/#headers","title":"Headers","text":"<p>Several other headers can have relevant metadata, such as the <code>Content-Type</code> header, or the <code>Link: &lt;http://www.w3.org/ns/ldp#Container&gt;; rel=\"type\"</code> header which is used to indicate to the server that a request intends to create a container.</p> <p>Such headers are converted to RDF triples and stored in the <code>RepresentationMetadata</code> object, which will be part of the <code>body</code> field in the <code>Operation</code>.</p> <p>The default <code>MetadataParser</code> is a <code>ParallelHandler</code> that contains several smaller parsers, each looking at a specific header.</p>"},{"location":"architecture/features/protocol/parsing/#body","title":"Body","text":"<p>In case of most requests, the input data stream is used directly in the <code>body</code> field of the <code>Operation</code>, with a few minor checks to make sure the HTTP specification is being followed.</p> <p>In the case of PATCH requests though, there are several specific body parsers that will convert the request into a JavaScript object containing all the necessary information to execute such a PATCH. Several validation checks will already take place there as well.</p>"},{"location":"architecture/features/protocol/parsing/#conditions","title":"Conditions","text":"<p>The <code>BasicConditionsParser</code> parses everything related to conditions headers, such as <code>if-none-match</code> or <code>if-modified-since</code>, and stores the relevant information in the <code>conditions</code> field of the <code>Operation</code>. These will later be used to make sure the request should be aborted or not.</p>"},{"location":"architecture/features/protocol/parsing/#sending-the-response","title":"Sending the response","text":"<p>In case a request is successful, the <code>AuthorizingHttpHandler</code> will return a <code>ResponseDescription</code>, and if not it will throw an error.</p> <p>In case an error gets thrown, this will be caught by the <code>ErrorHandler</code> and converted into a <code>ResponseDescription</code>. The request preferences will be used to make sure the serialization is one that is preferred.</p> <p>Either way we will have a <code>ResponseDescription</code>, which will be sent to the <code>BasicResponseWriter</code> to convert into output headers, data and a status code.</p> <p>To convert the metadata into headers, it uses a <code>MetadataWriter</code>, which functions as the reverse of the <code>MetadataParser</code> mentioned above: it has multiple writers which each convert certain metadata into a specific header.</p>"},{"location":"architecture/features/protocol/patching/","title":"Modifying resources","text":"<p>As described here, there is a generic solution for modifying resources as a result of PATCH requests. It consists of doing the following steps:</p> <ol> <li>Convert the stored resource to a stream of quad objects (a/k/a, a quad stream).</li> <li>Read the quad stream and ingest the quads into an N3.js Store.</li> <li>If the target resource is metadata, ensure that the immutable triples don't get changed.</li> <li>Apply the patch to the quad store.</li> <li>Convert the quad store to a quad stream.</li> <li>Convert the quad stream back to the original media type of the resource.</li> </ol> <p>The architecture is described more in-depth below.</p> <pre><code>flowchart LR\n  PatchingStore(\"&lt;strong&gt;ResourceStore_Patching&lt;/strong&gt;&lt;br&gt;ResourceStore\")\n  PatchingStore --&gt; PatchHandler(\"&lt;strong&gt;PatchHandler&lt;/strong&gt;&lt;br&gt;RepresentationPatchHandler\")\n  PatchHandler --&gt; Patchers(\"&lt;br&gt;WaterfallHandler\")\n  Patchers --&gt; ConvertingPatcher(\"&lt;br&gt;ConvertingPatcher\")\n  ConvertingPatcher --&gt; RdfPatcher(\"&lt;strong&gt;RdfPatcher&lt;/strong&gt;&lt;br&gt;RdfPatcher\")</code></pre> <pre><code>flowchart LR\n  RdfPatcher(\"&lt;strong&gt;RdfPatcher&lt;/strong&gt;&lt;br&gt;RdfPatcher\")\n  RdfPatcher --&gt; RDFStore(\"&lt;strong&gt;PatchHandler_RDFStore&lt;/strong&gt;&lt;br&gt;WaterfallHandler\")\n  RDFStore --&gt; RDFStoreArgs\n\n  subgraph RDFStoreArgs[\" \"]\n    Immutable(\"&lt;strong&gt;PatchHandler_ImmutableMetadata&lt;/strong&gt;&lt;br&gt;ImmutableMetadataPatcher\")\n    RDF(\"&lt;strong&gt;PatchHandler_RDF&lt;/strong&gt;&lt;br&gt;WaterfallHandler\")\n    Immutable --&gt; RDF\n  end\n\n  RDF --&gt; RDFArgs\n\n  subgraph RDFArgs[\" \"]\n    direction LR\n    N3(\"&lt;br&gt;N3Patcher\")\n    SPARQL(\"&lt;br&gt;SparqlUpdatePatcher\")\n  end</code></pre> <p>The <code>PatchingStore</code> is the entry point. It first checks whether the next store supports modifying resources. Only if this is not the case will it start the generic patching solution by calling its <code>PatchHandler</code>.</p> <p>The <code>RepresentationPatchHandler</code> calls the source <code>ResourceStore</code> to get a data stream representing the current state of the resource. It feeds that stream as input into a <code>RepresentationPatcher</code>, and then writes the result back to the store.</p> <p>Similarly to the way accessing resources is done through a stack of <code>ResourceStore</code>s, patching is done through a stack of <code>RepresentationPatcher</code>s, each performing a step in the patching process.</p> <p>The <code>ConvertingPatcher</code> is responsible for converting the original resource to a stream of quad objects, and converting the modified result back to the original type. By converting to quads, all other relevant classes can act independently of the actual RDF serialization type. For similar reasons, the <code>RdfPatcher</code> converts the quad stream to an <code>N3.js</code> Store so the next patchers do not have to worry about handling stream data and have access to the entire resource in memory.</p> <p>The <code>ImmutableMetadataPatcher</code> keeps track of a list of triples that cannot be modified in the metadata of a resource. For example, it is not possible to modify the metadata to indicate whether it is a storage root. The <code>ImmutableMetadataPatcher</code> tracks all these triples before and after a metadata resource is modified, and throws an error if one is modified. If the target resource is not metadata but a standard resource, this class will be skipped.</p> <p>Finally, either the <code>N3Patcher</code> or the <code>SparqlUpdatePatcher</code> will be called, depending on the type of patch that is requested.</p>"},{"location":"architecture/features/protocol/resource-store/","title":"Resource store","text":"<p>The interface of a <code>ResourceStore</code> is mostly a 1-to-1 mapping of the HTTP methods:</p> <ul> <li>GET: <code>getRepresentation</code></li> <li>PUT: <code>setRepresentation</code></li> <li>POST: <code>addResource</code></li> <li>DELETE: <code>deleteResource</code></li> <li>PATCH: <code>modifyResource</code></li> </ul> <p>The corresponding <code>OperationHandler</code> of the relevant method is responsible for calling the correct <code>ResourceStore</code> function.</p> <p>In practice, the community server has multiple resource stores chained together, each handling a specific part of the request and then calling the next store in the chain. The default configurations come with the following stores:</p> <ol> <li><code>MonitoringStore</code></li> <li><code>IndexRepresentationStore</code></li> <li><code>LockingResourceStore</code></li> <li><code>PatchingStore</code></li> <li><code>RepresentationConvertingStore</code></li> <li><code>DataAccessorBasedStore</code></li> </ol> <p>This chain can be seen in the configuration part in <code>config/storage/middleware/default.json</code> and all the entries in <code>config/storage/backend</code>.</p>"},{"location":"architecture/features/protocol/resource-store/#monitoringstore","title":"MonitoringStore","text":"<p>This store emits the events that are necessary to emit notifications when resources change.</p> <p>There are 4 different events that can be emitted:</p> <ul> <li><code>this.emit('changed', identifier, activity)</code>: is emitted for every resource that was changed/effected by a     call to the store.     With activity being undefined or one of the available ActivityStream terms.</li> <li><code>this.emit(AS.Create, identifier)</code>: is emitted for every resource that was created by the call to the store.</li> <li><code>this.emit(AS.Update, identifier)</code>: is emitted for every resource that was updated by the call to the store.</li> <li><code>this.emit(AS.Delete, identifier)</code>: is emitted for every resource that was deleted by the call to the store.</li> </ul> <p>A <code>changed</code> event will always be emitted if a resource was changed. If the correct metadata was set by the source <code>ResourceStore</code>, an additional field will be sent along indicating the type of change, and an additional corresponding event will be emitted, depending on what the change is.</p>"},{"location":"architecture/features/protocol/resource-store/#indexrepresentationstore","title":"IndexRepresentationStore","text":"<p>When doing a GET request on a container <code>/container/</code>, this container returns the contents of <code>/container/index.html</code> instead if HTML is the preferred response type. All these values are the defaults and can be configured for other resources and media types.</p>"},{"location":"architecture/features/protocol/resource-store/#lockingresourcestore","title":"LockingResourceStore","text":"<p>To prevent data corruption, the server locks resources when being targeted by a request. Locks are only released when an operation is completely finished, in the case of read operations this means the entire data stream is read, and in the case of write operations this happens when all relevant data is written. The default lock that is used is a readers-writer lock. This allows simultaneous read requests on the same resource, but only while no write request is in progress.</p>"},{"location":"architecture/features/protocol/resource-store/#patchingstore","title":"PatchingStore","text":"<p>PATCH operations in Solid apply certain transformations on the target resource, which makes them more complicated than only reading or writing data since it involves both. The <code>PatchingStore</code> provides a generic solution for backends that do not implement the <code>modifyResource</code> function so new backends can be added more easily. In case the next store in the chain does not support PATCH, the <code>PatchingStore</code> will GET the data from the next store, apply the transformation on that data, and then PUT it back to the store.</p>"},{"location":"architecture/features/protocol/resource-store/#representationconvertingstore","title":"RepresentationConvertingStore","text":"<p>This store handles everything related to content negotiation. In case the resulting data of a GET request does not match the preferences of a request, it will be converted here. Similarly, if incoming data does not match the type expected by the store, the SPARQL backend only accepts triples for example, that is also handled here</p>"},{"location":"architecture/features/protocol/resource-store/#dataaccessorbasedstore","title":"DataAccessorBasedStore","text":"<p>Large parts of the requirements of the Solid protocol specification are resolved by the <code>DataAccessorBasedStore</code>: POST only working on containers, DELETE not working on non-empty containers, generating <code>ldp:contains</code> triples for containers, etc. Most of this behaviour is independent of how the data is stored which is why it can be generalized here. The store's name comes from the fact that it makes use of <code>DataAccessor</code>s to handle the read/write of resources. A <code>DataAccessor</code> is a simple interface that only focuses on handling the data. It does not concern itself with any of the necessary Solid checks as it assumes those have already been made. This means that if a storage method needs to be supported, only a new <code>DataAccessor</code> needs to be made, after which it can be plugged into the rest of the server.</p>"},{"location":"contributing/making-changes/","title":"Pull requests","text":"<p>The community server is fully written in Typescript.</p> <p>All changes should be done through pull requests.</p> <p>We recommend first discussing a possible solution in the relevant issue to reduce the amount of changes that will be requested.</p> <p>In case any of your changes are breaking, make sure you target the next major branch (<code>versions/x.0.0</code>) instead of the main branch. Breaking changes include: changing interface/class signatures, potentially breaking external custom configurations, and breaking how internal data is stored. In case of doubt you probably want to target the next major branch.</p> <p>We make use of Conventional Commits.</p> <p>Don't forget to update the release notes when adding new major features. Also update any relevant documentation in case this is needed.</p> <p>When making changes to a pull request, we prefer to update the existing commits with a rebase instead of appending new commits, this way the PR can be rebased directly onto the target branch instead of needing to be squashed.</p> <p>There are strict requirements from the linter and the test coverage before a PR is valid. These are configured to run automatically when trying to commit to git. Although there are no tests for it (yet), we strongly advice documenting with TSdoc.</p> <p>If a list of entries is alphabetically sorted, such as index.ts, make sure it stays that way.</p>"},{"location":"contributing/release/","title":"Releasing a new version","text":"<p>This is only relevant if you are a developer with push access responsible for doing a new release.</p> <p>Steps to follow:</p> <ul> <li>Major releases only:<ul> <li>Merge <code>main</code> into <code>versions/next-major</code>.</li> </ul> </li> <li>Verify if there are issues when upgrading an existing installation to the new version.<ul> <li>Can the data still be accessed?</li> <li>Does authentication still work?</li> <li>Is there an issue upgrading any of the dependent repositories (see below for links)?</li> <li>None of the above has to be blocking per se, but should be noted in the release notes if relevant.</li> </ul> </li> <li>Major and Minor releases:<ul> <li>Verify that the <code>RELEASE_NOTES.md</code> are correct.</li> </ul> </li> <li><code>npm run release -- -r major/minor/patch</code><ul> <li>Automatically updates Components.js references to the new version in case of a major release.   Committed with <code>chore(release): Update configs to vx.0.0</code>.</li> <li>Updates the <code>package.json</code>, and generates the new entries in <code>CHANGELOG.md</code>.   Commits with <code>chore(release): Release version vx.y.z of the npm package</code></li> <li>Optionally run <code>npx commit-and-tag-version -r major/minor/patch --dry-run</code> to preview the commands that will be run   and the changes to <code>CHANGELOG.md</code>.</li> </ul> </li> <li>The <code>postrelease</code> script will now prompt you to manually edit the <code>CHANGELOG.md</code>.<ul> <li>All entries are added in separate sections of the new release according to their commit prefixes.</li> <li>Re-organize the entries accordingly, referencing previous releases. Most of the entries in Chores and   Documentation can be removed.</li> <li>Press any key in your terminal when your changes are ready.</li> <li>The <code>postrelease</code> script will amend the release commit, create an annotated tag and push changes to origin.</li> </ul> </li> <li>Major releases only:<ul> <li>Merge <code>versions/next-major</code> into <code>main</code> and push.</li> </ul> </li> <li>Do a GitHub release.</li> <li><code>npm publish</code></li> <li>If there is no pre-release of a higher version:<ul> <li><code>npm dist-tag add @solid/community-server@x.y.z next</code></li> </ul> </li> <li>Potentially upgrade dependent repositories:<ul> <li>Recipes at https://github.com/CommunitySolidServer/recipes/</li> <li>Tutorials at https://github.com/CommunitySolidServer/tutorials/</li> <li>Generator at https://github.com/CommunitySolidServer/configuration-generator/</li> <li>Hello world component at https://github.com/CommunitySolidServer/hello-world-component/</li> </ul> </li> </ul>"},{"location":"contributing/release/#changes-when-doing-a-pre-release","title":"Changes when doing a pre-release","text":"<ul> <li>Version with <code>npm run release -- -r major --prerelease alpha</code></li> <li>Do not merge <code>versions/next-major</code> into <code>main</code>.</li> <li>Publish with <code>npm publish --tag next</code>.</li> </ul>"},{"location":"features/test/","title":"Testing the server","text":"<p>There are several test sets in place to ensure the server conforms to the necessary requirements, and to prevent changes from breaking this.</p>"},{"location":"features/test/#unit-tests","title":"Unit tests","text":"<p>For every TypeScript file, most of which correspond to a single class implementation, there is a corresponding unit test file in the <code>test/unit</code> folder. These tests require 100% code coverage over the corresponding implementation, making sure every line is checked.</p> <p>These tests can be run using the <code>npm run test:unit</code> script.</p>"},{"location":"features/test/#integration-tests","title":"Integration tests","text":"<p>The <code>test/integration</code> folder contains several test suites that set up a complete server instance and validate its functionality. <code>test/intergration/config</code> contains the configurations used by these test suites. These make sure that no features get lost after changes are made to the server.</p> <p>These tests can be run using the <code>npm run test:integration</code> script.</p>"},{"location":"features/test/#specification-conformance","title":"Specification conformance","text":"<p>To make sure the server conforms to the Solid specification, we run the Conformance Test Harness (CTH) combined with the specification test suite. This test suite was made specifically so any Solid server can be tested on how well it conforms to the Solid specifications. The configuration that runs these tests in the repository can be found here.</p> <p>You can also run this test suite locally. Besides the standard requirements for running the server, this also requires Docker. First make sure you have a running CSS instance, in this example we will assume it is running at <code>http://localhost:3000</code>. After that you can run the following commands. The paths are relative to the root folder of your CSS source folder, and should be adjusted accordingly if you are not running this from the source folder.</p> <pre><code># Generate the folder where the reports will be located\nmkdir -p ../conformance/reports/css\n\n# Pull the CTH Docker image\ndocker pull solidproject/conformance-test-harness\n\n# Set up the env file necessary for the CTH\necho 'SOLID_IDENTITY_PROVIDER=http://localhost:3000/idp/\nUSERS_ALICE_WEBID=http://localhost:3000/alice/profile/card#me\nUSERS_BOB_WEBID=http://localhost:3000/bob/profile/card#me\nRESOURCE_SERVER_ROOT=http://localhost:3000\nTEST_CONTAINER=/alice/\nquarkus.log.category.\"ResultLogger\".level=INFO\nquarkus.log.category.\"com.intuit.karate\".level=DEBUG\nquarkus.log.category.\"org.solid.testharness.http.Client\".level=DEBUG\nquarkus.log.category.\"org.solid.testharness.http.AuthManager\".level=DEBUG\nMAXTHREADS=1' &gt; ../conformance/conformance.env\n\n# Generate the test users required by the CTH on the server to be tested\nnpx ts-node test/deploy/createAccountCredentials.ts http://localhost:3000/ &gt;&gt; ../conformance/conformance.env\n\n# Run the CTH\ndocker run -i --rm \\\n          -v $(pwd)/../conformance/reports/css:/reports \\\n          --env-file=../conformance/conformance.env \\\n          --network=\"host\" \\\n          solidproject/conformance-test-harness \\\n          --skip-teardown \\\n          --output=/reports \\\n          --target=https://github.com/solid/conformance-test-harness/css\n</code></pre> <p>When this process is finished you can find the conformance report in the <code>../reports/css</code> folder.</p>"},{"location":"usage/authorization-methods/","title":"Choosing the authorization method for your server","text":"<p>The CSS comes with support for two different authorization solutions: Web Access Control (WAC) and Access Control Policy (ACP). When configuring a server, one of these needs to be picked if you do not want everyone to have full access to your data. Both of these are similar in that they both make use of RDF resources to describe who can access which documents,</p> <p>WAC is the older specification of the two, it was designed together with the beginning of the Solid specification. Because of that, there is more tooling available that can interpret the corresponding authorization resources, potentially making it easier to get started with Solid development.</p> <p>ACP is a more recent specification, that was made to address certain concerns within WAC. ACP provides more options in how to define who gets to access your data, allowing you to have better security.</p> <p>When using WAC, you define which WebIDs have access to certain data. When you then authenticate with a Solid client, that client will identify with your WebID, indicating to the server that it is allowed to access that data. The problem is that there is no (safe) way to differentiate between clients. This means that if you use a client to store your favorite movies in your pod, and another one to store your bank details, the movie client would be able to access your bank details if it was malicious. ACP on the other hand allows you to set more specific restrictions, where clients also have to identify themselves. This way you can make sure the movie client can only access movie data.</p> <p>Currently, the CSS still enables WAC in most of the configurations bundled with the server, as we want the server to be easily accessible for newer users, for whom the chances are higher they are using apps only compatible with WAC. However, we are planning to eventually phase this out in favor of ACP, starting with logged warnings when WAC is enabled, and in the end changing the bundled configurations to use ACP instead.</p>"},{"location":"usage/client-credentials/","title":"Automating authentication with Client Credentials","text":"<p>One potential issue for scripts and other applications is that it requires user interaction to log in and authenticate. The CSS offers an alternative solution for such cases by making use of Client Credentials. Once you have created an account as described in the Identity Provider section, users can request a token that apps can use to authenticate without user input.</p> <p>All requests to the client credentials API currently require you to send along the email and password of that account to identify yourself. This is a temporary solution until the server has more advanced account management, after which this API will change.</p> <p>Below is example code of how to make use of these tokens. It makes use of several utility functions from the Solid Authentication Client. Note that the code below uses top-level <code>await</code>, which not all JavaScript engines support, so this should all be contained in an <code>async</code> function.</p>"},{"location":"usage/client-credentials/#generating-a-token","title":"Generating a token","text":"<p>A token can be created either on your account page, by default <code>http://localhost:3000/.account/</code>, or by calling the relevant API.</p> <p>Below is an example of how to call the API to generate such a token.</p> <p>The code below generates a token linked to your account and WebID. This only needs to be done once, afterwards this token can be used for all future requests.</p> <p>Before doing the step below, you already need to have an authorization value that you get after logging in to your account.</p> <p>Below is an example of how this would work with the email/password API from the default server configurations.</p> <pre><code>// All these examples assume the server is running at `http://localhost:3000/`.\n\n// First we request the account API controls to find out where we can log in\nconst indexResponse = await fetch('http://localhost:3000/.account/');\nconst { controls } = await indexResponse.json();\n\n// And then we log in to the account API\nconst response = await fetch(controls.password.login, {\n  method: 'POST',\n  headers: { 'content-type': 'application/json' },\n  body: JSON.stringify({ email: 'my-email@example.com', password: 'my-password' }),\n});\n// This authorization value will be used to authenticate in the next step\nconst { authorization } = await response.json();\n</code></pre> <p>The next step generates the token and assumes you have an authorization value as generated in the example above.</p> <pre><code>// Now that we are logged in, we need to request the updated controls from the server.\n// These will now have more values than in the previous example.\nconst indexResponse = await fetch('http://localhost:3000/.account/', {\n  headers: { authorization: `CSS-Account-Token ${authorization}` }\n});\nconst { controls } = await indexResponse.json();\n\n// Here we request the server to generate a token on our account\nconst response = await fetch(controls.account.clientCredentials, {\n  method: 'POST',\n  headers: { authorization: `CSS-Account-Token ${authorization}`, 'content-type': 'application/json' },\n  // The name field will be used when generating the ID of your token.\n  // The WebID field determines which WebID you will identify as when using the token.\n  // Only WebIDs linked to your account can be used.\n  body: JSON.stringify({ name: 'my-token', webId: 'http://localhost:3000/my-pod/card#me' }),\n});\n\n// These are the identifier and secret of your token.\n// Store the secret somewhere safe as there is no way to request it again from the server!\n// The `resource` value can be used to delete the token at a later point in time.\nconst { id, secret, resource } = await response.json();\n</code></pre> <p>In case something goes wrong the status code will be 400/500 and the response body will contain a description of the problem.</p>"},{"location":"usage/client-credentials/#requesting-an-access-token","title":"Requesting an Access token","text":"<p>The ID and secret combination generated above can be used to request an Access Token from the server. This Access Token is only valid for a certain amount of time, after which a new one needs to be requested.</p> <pre><code>import { createDpopHeader, generateDpopKeyPair } from '@inrupt/solid-client-authn-core';\n\n// A key pair is needed for encryption.\n// This function from `solid-client-authn` generates such a pair for you.\nconst dpopKey = await generateDpopKeyPair();\n\n// These are the ID and secret generated in the previous step.\n// Both the ID and the secret need to be form-encoded.\nconst authString = `${encodeURIComponent(id)}:${encodeURIComponent(secret)}`;\n// This URL can be found by looking at the \"token_endpoint\" field at\n// http://localhost:3000/.well-known/openid-configuration\n// if your server is hosted at http://localhost:3000/.\nconst tokenUrl = 'http://localhost:3000/.oidc/token';\nconst response = await fetch(tokenUrl, {\n  method: 'POST',\n  headers: {\n    // The header needs to be in base64 encoding.\n    authorization: `Basic ${Buffer.from(authString).toString('base64')}`,\n    'content-type': 'application/x-www-form-urlencoded',\n    dpop: await createDpopHeader(tokenUrl, 'POST', dpopKey),\n  },\n  body: 'grant_type=client_credentials&amp;scope=webid',\n});\n\n// This is the Access token that will be used to do an authenticated request to the server.\n// The JSON also contains an \"expires_in\" field in seconds,\n// which you can use to know when you need request a new Access token.\nconst { access_token: accessToken } = await response.json();\n</code></pre>"},{"location":"usage/client-credentials/#using-the-access-token-to-make-an-authenticated-request","title":"Using the Access token to make an authenticated request","text":"<p>Once you have an Access token, you can use it for authenticated requests until it expires.</p> <pre><code>import { buildAuthenticatedFetch } from '@inrupt/solid-client-authn-core';\n\n// The DPoP key needs to be the same key as the one used in the previous step.\n// The Access token is the one generated in the previous step.\nconst authFetch = await buildAuthenticatedFetch(accessToken, { dpopKey });\n// authFetch can now be used as a standard fetch function that will authenticate as your WebID.\n// This request will do a simple GET for example.\nconst response = await authFetch('http://localhost:3000/private');\n</code></pre>"},{"location":"usage/client-credentials/#other-token-actions","title":"Other token actions","text":"<p>You can see all your existing tokens on your account page or by doing a GET request to the same API to create a new token. The details of a token can be seen by doing a GET request to the resource URL of the token.</p> <p>A token can be deleted by doing a DELETE request to the resource URL of the token.</p> <p>All of these actions require you to be logged in to the account.</p>"},{"location":"usage/dev-configuration/","title":"Configuring the CSS as a development server in another project","text":"<p>It can be useful to use the CSS as local server to develop Solid applications against. There are several ways to configure and run a server in your project. Note that starting up the server takes some time so set your timeout high enough if you are using this in your tests.</p>"},{"location":"usage/dev-configuration/#starting-the-server-through-code","title":"Starting the server through code","text":"<p>You can create a server instance in your code, or tests, by calling the <code>create</code> function of a new <code>AppRunner</code> instance. The resulting object has <code>start</code> and <code>stop</code> functions. The <code>create</code> function takes as input an object with 5 optional parameters which can all be used to define the server configuration. None of these are mandatory, if you don't think you need one you can probably ignore it. These are discussed below.</p>"},{"location":"usage/dev-configuration/#loaderproperties","title":"loaderProperties","text":"<p>These values are specifically to configure how Components.js handles starting the server. Most of these are generally not going to be relevant, but here are some of those you might want to change:</p> <ul> <li>mainModulePath: Determines where Components.js will look for components.                         Defaults to the folder where the server dependency is installed.                         In case you are making a custom component,                         this value needs to point to the directory of your project instead.</li> <li>logLevel: The logging level of Components.js when building. Defaults to <code>warn</code>.</li> </ul>"},{"location":"usage/dev-configuration/#config","title":"config","text":"<p>The file path of the Components.js configuration that needs to be used. This can also be an array of configuration paths. The <code>@css:</code> prefix can be used for file paths to generate a path relative to the folder where the server dependency is installed. Defaults to <code>@css:config/default.json</code>.</p>"},{"location":"usage/dev-configuration/#variablebindings","title":"variableBindings","text":"<p>Allows you to assign values to the variables that are used in a Components.js configuration. For example, <code>{ 'urn:solid-server:default:variable:port': 3000  }</code> tells the server to use port 3000.</p>"},{"location":"usage/dev-configuration/#shorthand","title":"shorthand","text":"<p>Allows you to assign values to parameters similarly as if you would call the server from the CLI. For example, <code>{ port: 3000  }</code> tells the server to use port 3000.</p> <p>This is very similar to the <code>variableBindings</code> field mentioned above, as CLI parameters all get translated into Components.js variables, although some get transformed before being put into a variable. If you are not sure which one to use, <code>shorthand</code> is the safer choice to use.</p>"},{"location":"usage/dev-configuration/#argv","title":"argv","text":"<p>If used, this parameter expects a string array. Here you can provide the raw dump of CLI values, so you don't have to parse them yourself, should this be useful for your application.</p>"},{"location":"usage/dev-configuration/#configuring-the-server-in-packagejson","title":"Configuring the server in <code>package.json</code>","text":"<p>As an alternative to using CLI arguments, or environment variables, the CSS can be configured in the <code>package.json</code> as follows:</p> <pre><code>{\n  \"name\": \"test\",\n  \"version\": \"0.0.0\",\n  \"private\": \"true\",\n  \"config\": {\n    \"community-solid-server\": {\n      \"port\": 3001,\n      \"loggingLevel\": \"error\"\n    }\n  },\n  \"scripts\": {\n    \"dev:pod\": \"community-solid-server\"\n  },\n  \"devDependencies\": {\n    \"@solid/community-server\": \"^7.0.0\"\n  }\n}\n</code></pre> <p>These parameters will then be used when the <code>community-solid-server</code> command is executed as an <code>npm</code> script (as shown in the example above). Or whenever the <code>community-solid-server</code> command is executed in the same folder as the <code>package.json</code>.</p> <p>Alternatively, the configuration parameters may be placed in a configuration file named <code>.community-solid-server.config.json</code> as follows:</p> <pre><code>{\n  \"port\": 3001,\n  \"loggingLevel\": \"error\"\n}\n</code></pre> <p>The config may also be written in JavaScript with the config as the default export such as the following <code>.community-solid-server.config.js</code>:</p> <pre><code>module.exports = {\n  port: 3001,\n  loggingLevel: 'error'\n};\n</code></pre>"},{"location":"usage/example-requests/","title":"Interacting with the server","text":""},{"location":"usage/example-requests/#put-creating-resources-for-a-given-url","title":"<code>PUT</code>: Creating resources for a given URL","text":"<p>Create a plain text file:</p> <pre><code>curl -X PUT -H \"Content-Type: text/plain\" \\\n  -d \"abc\" \\\n  http://localhost:3000/myfile.txt\n</code></pre> <p>Create a turtle file:</p> <pre><code>curl -X PUT -H \"Content-Type: text/turtle\" \\\n  -d \"&lt;ex:s&gt; &lt;ex:p&gt; &lt;ex:o&gt;.\" \\\n  http://localhost:3000/myfile.ttl\n</code></pre>"},{"location":"usage/example-requests/#post-creating-resources-at-a-generated-url","title":"<code>POST</code>: Creating resources at a generated URL","text":"<p>Create a plain text file:</p> <pre><code>curl -X POST -H \"Content-Type: text/plain\" \\\n  -d \"abc\" \\\n  http://localhost:3000/\n</code></pre> <p>Create a turtle file:</p> <pre><code>curl -X POST -H \"Content-Type: text/turtle\" \\\n  -d \"&lt;ex:s&gt; &lt;ex:p&gt; &lt;ex:o&gt;.\" \\\n  http://localhost:3000/\n</code></pre> <p>The response's <code>Location</code> header will contain the URL of the created resource.</p>"},{"location":"usage/example-requests/#get-retrieving-resources","title":"<code>GET</code>: Retrieving resources","text":"<p>Retrieve a plain text file:</p> <pre><code>curl -H \"Accept: text/plain\" \\\n  http://localhost:3000/myfile.txt\n</code></pre> <p>Retrieve a turtle file:</p> <pre><code>curl -H \"Accept: text/turtle\" \\\n  http://localhost:3000/myfile.ttl\n</code></pre> <p>Retrieve a turtle file in a different serialization:</p> <pre><code>curl -H \"Accept: application/ld+json\" \\\n  http://localhost:3000/myfile.ttl\n</code></pre>"},{"location":"usage/example-requests/#delete-deleting-resources","title":"<code>DELETE</code>: Deleting resources","text":"<pre><code>curl -X DELETE http://localhost:3000/myfile.txt\n</code></pre>"},{"location":"usage/example-requests/#patch-modifying-resources","title":"<code>PATCH</code>: Modifying resources","text":"<p>Modify a resource using N3 Patch:</p> <pre><code>curl -X PATCH -H \"Content-Type: text/n3\" \\\n  --data-raw \"@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;. _:rename a solid:InsertDeletePatch; solid:inserts { &lt;ex:s2&gt; &lt;ex:p2&gt; &lt;ex:o2&gt;. }.\" \\\n  http://localhost:3000/myfile.ttl\n</code></pre> <p>Modify a resource using SPARQL Update:</p> <pre><code>curl -X PATCH -H \"Content-Type: application/sparql-update\" \\\n  -d \"INSERT DATA { &lt;ex:s2&gt; &lt;ex:p2&gt; &lt;ex:o2&gt; }\" \\\n  http://localhost:3000/myfile.ttl\n</code></pre>"},{"location":"usage/example-requests/#head-retrieve-resources-headers","title":"<code>HEAD</code>: Retrieve resources headers","text":"<pre><code>curl -I -H \"Accept: text/plain\" \\\n  http://localhost:3000/myfile.txt\n</code></pre>"},{"location":"usage/example-requests/#options-retrieve-resources-communication-options","title":"<code>OPTIONS</code>: Retrieve resources communication options","text":"<pre><code>curl -X OPTIONS -i http://localhost:3000/myfile.txt\n</code></pre>"},{"location":"usage/identity-provider/","title":"Identity Provider","text":"<p>Besides implementing the Solid protocol, the community server can also be an Identity Provider (IDP), officially known as an OpenID Provider (OP), following the Solid-OIDC specification as much as possible.</p> <p>It is recommended to use the latest version of the Solid authentication client to interact with the server.</p> <p>It also provides account management options for creating pods and WebIDs to be used during authentication, which are discussed more in-depth below. The links on this page assume the server is hosted at <code>http://localhost:3000/</code>.</p>"},{"location":"usage/identity-provider/#registering-an-account","title":"Registering an account","text":"<p>To register an account, you can go to <code>http://localhost:3000/.account/password/register/</code>, if this feature is enabled. There you can create an account with the email/password login method. The password will be salted and hashed before being stored. Afterwards you will be redirected to the account page where you can create pods and link WebIDs to your account.</p>"},{"location":"usage/identity-provider/#creating-a-pod","title":"Creating a pod","text":"<p>To create a pod you simply have to fill in the name you want your pod to have. This will then be used to generate the full URL of your pod. For example, if you choose the name <code>test</code>, your pod would be located at <code>http://localhost:3000/test/</code> and your generated WebID would be <code>http://localhost:3000/test/profile/card#me</code>.</p> <p>If you fill in a WebID when creating the pod, that WebID will be the one that has access to all data in the pod. If you don't, a WebID will be created in the pod and immediately linked to your account, allowing you to use it for authentication and accessing the data in that pod</p> <p>The generated name also depends on the configuration you chose for your server. If you are using the subdomain feature, the generated pod URL would be <code>http://test.localhost:3000/</code>.</p>"},{"location":"usage/identity-provider/#webids","title":"WebIDs","text":"<p>To use Solid authentication, you need to link at least one WebID to your account. This can happen automatically when creating a pod as mentioned above, or can be done manually with external WebIDs.</p> <p>If you try to link an external WebID, the first attempt will return an error indicating you need to add an identification triple to your WebID. After doing that you can try to register again. This is how we verify you are the owner of that WebID. Afterwards the page will inform you that you have to add a triple to your WebID if you want to use the server as your IDP.</p>"},{"location":"usage/identity-provider/#logging-in","title":"Logging in","text":"<p>When using an authenticating client, you will be redirected to a login screen asking for your email and password. After that you will be redirected to a page showing some basic information about the client where you can pick the WebID you want to use. There you need to consent that this client is allowed to identify using that WebID. As a result the server will send a token back to the client that contains all the information needed to use your WebID.</p>"},{"location":"usage/identity-provider/#forgot-password","title":"Forgot password","text":"<p>If you forgot your password, you can recover it by going to <code>http://localhost:3000/.account/login/password/forgot/</code>. There you can enter your email address to get a recovery mail to reset your password. This feature only works if a mail server was configured, which by default is not the case.</p>"},{"location":"usage/identity-provider/#json-api","title":"JSON API","text":"<p>All of the above happens through HTML pages provided by the server. By default, the server uses the templates found in <code>/templates/identity/</code> but different templates can be used through configuration.</p> <p>These templates all make use of a JSON API exposed by the server. A full description of this API can be found here.</p>"},{"location":"usage/identity-provider/#idp-configuration","title":"IDP configuration","text":"<p>The above descriptions cover server behaviour with most default configurations, but just like any other feature, there are several features that can be changed through the imports in your configuration file.</p> <p>All available options can be found in the <code>config/identity/</code> folder. Below we go a bit deeper into the available options</p>"},{"location":"usage/identity-provider/#access","title":"access","text":"<p>The <code>access</code> option allows you to set authorization restrictions on the IDP API when enabled, similar to how authorization works on the LDP requests on the server. For example, if the server uses WebACL as authorization scheme, you can put a <code>.acl</code> resource in the <code>/.account/account/</code> container to restrict who is allowed to access the account creation API. Note that for everything to work there needs to be a <code>.acl</code> resource in <code>/.account/</code> when using WebACL so resources can be accessed as usual when the server starts up. Make sure you change the permissions on <code>/.account/.acl</code> so not everyone can modify those.</p> <p>All of the above is only relevant if you use the <code>restricted.json</code> setting for this import. When you use <code>public.json</code> the API will simply always be accessible by everyone.</p>"},{"location":"usage/identity-provider/#email","title":"email","text":"<p>In case you want users to be able to reset their password when they forget it, you will need to tell the server which email server to use to send reset mails. <code>example.json</code> contains an example of what this looks like. When using this import, you can override the values with those of your own mail client by adding the following to your <code>Components.js</code> configuration with updated values:</p> <pre><code>{\n  \"comment\": \"The settings of your email server.\",\n  \"@type\": \"Override\",\n  \"overrideInstance\": {\n    \"@id\": \"urn:solid-server:default:EmailSender\"\n  },\n  \"overrideParameters\": {\n    \"@type\": \"BaseEmailSender\",\n    \"senderName\": \"Community Solid Server &lt;solid@example.email&gt;\",\n    \"emailConfig_host\": \"smtp.example.email\",\n    \"emailConfig_port\": 587,\n    \"emailConfig_auth_user\": \"solid@example.email\",\n    \"emailConfig_auth_pass\": \"NYEaCsqV7aVStRCbmC\"\n  }\n}\n</code></pre>"},{"location":"usage/identity-provider/#handler","title":"handler","text":"<p>Here you determine which features of account management are available. <code>default.json</code> allows everything, <code>disabled.json</code> completely disables account management, and the other options disable account and/or pod creation.</p>"},{"location":"usage/identity-provider/#pod","title":"pod","text":"<p>The <code>pod</code> options determines how pods are created. <code>static.json</code> is the expected pod behaviour as described above. <code>dynamic.json</code> is an experimental feature that allows users to have a custom Components.js configuration for their own pod. When using such a configuration, a JSON file will be written containing all the information of the user pods, so they can be recreated when the server restarts.</p>"},{"location":"usage/identity-provider/#adding-a-new-login-method-to-the-server","title":"Adding a new login method to the server","text":"<p>Due to its modular nature, it is possible to add new login methods to the server, allowing users to log in different ways than just the standard email/password combination. More information on what is required can be found here.</p>"},{"location":"usage/identity-provider/#data-migration","title":"Data migration","text":"<p>Going from v6 to v7 of the server, the account management is completely rewritten, including how account data is stored on the server. More information about how account data of an existing server can be migrated to the newer version can be found here.</p>"},{"location":"usage/metadata/","title":"Editing metadata of resources","text":""},{"location":"usage/metadata/#what-is-a-description-resource","title":"What is a description resource","text":"<p>Description resources contain auxiliary information about a resource. In CSS, these represent metadata corresponding to that resource. Every resource always has a corresponding description resource and therefore description resources can not be created or deleted directly.</p> <p>Description resources are discoverable by interacting with their subject resource: the response to a <code>GET</code> or <code>HEAD</code> request on a subject resource will contain a <code>describedby</code> Link Header with a URL that points to its description resource.</p> <p>Clients should always follow this link rather than guessing its URL, because the Solid Protocol does not mandate a specific description resource URL. The default CSS configurations use as a convention that <code>http://example.org/resource</code> has <code>http://example.org/resource.meta</code> as its description resource.</p>"},{"location":"usage/metadata/#how-to-edit-the-metadata-of-a-resource","title":"How to edit the metadata of a resource","text":"<p>Editing the metadata of a resource is performed by editing the description resource directly. This can only be done using <code>PATCH</code> requests (see example workflow).</p> <p><code>PUT</code> requests on description resources are not allowed, because they would replace the entire resource state, whereas some metadata is protected or generated by the server.</p> <p>Similarly, <code>DELETE</code> on description resources is not allowed because a resource will always have some metadata (e.g. <code>rdf:type</code>). Instead, the lifecycle of description resources is managed by the server.</p>"},{"location":"usage/metadata/#protected-metadata","title":"Protected metadata","text":"<p>Some metadata is managed by the server and can not be modified directly, such as the last modified date. The CSS will throw an error (409 <code>ConflictHttpError</code>) when trying to change this protected metadata.</p>"},{"location":"usage/metadata/#preserving-metadata","title":"Preserving metadata","text":"<p><code>PUT</code> requests on a resource will reset the description resource. There is however a way to keep the contents of description resource prior to the <code>PUT</code> request: adding the HTTP <code>Link</code> header targeting the description resource with <code>rel=\"preserve\"</code>.</p> <p>When the resource URL is <code>http://localhost:3000/foobar</code>, preserving its description resource when updating its contents can be achieved like in the following example:</p> <pre><code>curl -X PUT 'http://localhost:3000/foobar' \\\n-H 'Content-Type: text/turtle' \\\n-H 'Link: &lt;http://localhost:3000/foobar.meta&gt;;rel=\"preserve\"' \\\n-d \"&lt;ex:s&gt; &lt;ex:p&gt; &lt;ex:o&gt;.\"\n</code></pre>"},{"location":"usage/metadata/#impact-on-creating-containers","title":"Impact on creating containers","text":"<p>When creating a container the input body is ignored and performing a <code>PUT</code> request on an existing container will result in an error. Container metadata can only be added and modified by performing a <code>PATCH</code> on the description resource, similarly to documents. This is done to clearly differentiate between a container's representation and its metadata.</p>"},{"location":"usage/metadata/#example-of-a-workflow-for-editing-a-description-resource","title":"Example of a workflow for editing a description resource","text":"<p>In this example, we add an inbox description to <code>http://localhost:3000/foo/</code>. This allows discovery of the <code>ldp:inbox</code> as described in the Linked Data Notifications specification.</p> <p>We have started the CSS with the default configuration and have already created an inbox at <code>http://localhost:3000/inbox/</code>.</p> <p>Since we don't know the location of the description resource, we first send a <code>HEAD</code> request to the resource to obtain the URL of its description resource.</p> <pre><code>curl --head 'http://localhost:3000/foo/'\n</code></pre> <p>which will produce a response with at least these headers:</p> <pre><code>HTTP/1.1 200 OK\nLink: &lt;http://localhost:3000/foo/.meta&gt;; rel=\"describedby\"\n</code></pre> <p>Now that we have the URL of the description resource, we create a patch for adding the inbox in the description of the resource.</p> <pre><code>curl -X PATCH 'http://localhost:3000/foo/.meta' \\\n-H 'Content-Type: text/n3' \\\n--data-raw '@prefix solid: &lt;http://www.w3.org/ns/solid/terms#&gt;.\n&lt;&gt; a solid:InsertDeletePatch;\nsolid:inserts { &lt;http://localhost:3000/foo/&gt; &lt;http://www.w3.org/ns/ldp#inbox&gt; &lt;http://localhost:3000/inbox/&gt;. }.'\n</code></pre> <p>After this update, we can verify that the inbox is added by performing a GET request to the description resource</p> <pre><code>curl 'http://localhost:3000/foo/.meta'\n</code></pre> <p>With as result for the body</p> <pre><code>@prefix dc: &lt;http://purl.org/dc/terms/&gt;.\n@prefix ldp: &lt;http://www.w3.org/ns/ldp#&gt;.\n@prefix posix: &lt;http://www.w3.org/ns/posix/stat#&gt;.\n@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;.\n\n&lt;http://localhost:3000/foo/&gt; a ldp:Container, ldp:BasicContainer, ldp:Resource;\n    dc:modified \"2022-06-09T08:17:07.000Z\"^^xsd:dateTime;\n    ldp:inbox &lt;http://localhost:3000/inbox/&gt;;.\n</code></pre> <p>This can also be verified by sending a GET request to the subject resource itself. The inbox location can also be found in the Link headers.</p> <pre><code>curl -v 'http://localhost:3000/foo/'\n</code></pre> <pre><code>HTTP/1.1 200 OK\nLink: &lt;http://localhost:3000/inbox/&gt;; rel=\"http://www.w3.org/ns/ldp#inbox\"\n</code></pre>"},{"location":"usage/notifications/","title":"Receiving notifications","text":"<p>A CSS instance can be configured to support Solid notifications. These can be used to track changes on the server. There are no specific requirements on the type of notifications a Solid server should support, so on this page we'll describe the notification types supported by CSS, and how to make use of the different ways supported to receive notifications.</p>"},{"location":"usage/notifications/#discovering-subscription-services","title":"Discovering subscription services","text":"<p>CSS only supports discovering the notification subscription services through the storage description resource. This can be found by doing a <code>HEAD</code> request on any resource in your pod and looking for the <code>Link</code> header with the <code>http://www.w3.org/ns/solid/terms#storageDescription</code> relationship.</p> <p>For example, when hosting the server on localhost with port 3000, the result is:</p> <pre><code>Link: &lt;http://localhost:3000/.well-known/solid&gt;; rel=\"http://www.w3.org/ns/solid/terms#storageDescription\"\n</code></pre> <p>Doing a GET to <code>http://localhost:3000/.well-known/solid</code> then gives the following result (simplified for readability):</p> <pre><code>@prefix notify: &lt;http://www.w3.org/ns/solid/notifications#&gt;.\n\n&lt;http://localhost:3000/.well-known/solid&gt;\n    a                   &lt;http://www.w3.org/ns/pim/space#Storage&gt; ;\n    notify:subscription &lt;http://localhost:3000/.notifications/WebSocketChannel2023/&gt; ,\n                        &lt;http://localhost:3000/.notifications/WebhookChannel2023/&gt; .\n&lt;http://localhost:3000/.notifications/WebSocketChannel2023/&gt;\n    notify:channelType  notify:WebSocketChannel2023 ;\n    notify:feature      notify:accept ,\n                        notify:endAt ,\n                        notify:rate ,\n                        notify:startAt ,\n                        notify:state .\n&lt;http://localhost:3000/.notifications/WebhookChannel2023/&gt;\n    notify:channelType  notify:WebhookChannel2023;\n    notify:feature      notify:accept ,\n                        notify:endAt ,\n                        notify:rate ,\n                        notify:startAt ,\n                        notify:state .\n</code></pre> <p>This says that there are two available subscription services that can be used for notifications and where to find them. Note that these discovery requests also support content-negotiation, so you could ask for JSON-LD if you prefer. Currently, however, this JSON-LD will not match the examples from the notification specification.</p> <p>The above tells us where to send subscriptions and which features are supported for those services. You subscribe to a channel by <code>POST</code>ing a JSON-LD document to the subscription services. There are some small differences in the structure of these documents, depending on the channel type, which will be discussed below.</p> <p>Subscription requests need to be authenticated using Solid-OIDC. The server will check whether you have <code>Read</code> permission on the resource you want to listen to. Requests without <code>Read</code> permission will be rejected.</p>"},{"location":"usage/notifications/#notification-channel-types","title":"Notification channel types","text":"<p>There are currently up to two supported ways to get notifications in CSS, depending on your configuration: the notification channel types <code>WebSocketChannel2023</code>; and <code>WebhookChannel2023</code>.</p>"},{"location":"usage/notifications/#websockets","title":"WebSockets","text":"<p>To subscribe to the <code>http://localhost:3000/foo</code> resource using WebSockets, you use an authenticated <code>POST</code> request to send the following JSON-LD document to the server, at <code>http://localhost:3000/.notifications/WebSocketChannel2023/</code>:</p> <pre><code>{\n  \"@context\": [ \"https://www.w3.org/ns/solid/notification/v1\" ],\n  \"type\": \"http://www.w3.org/ns/solid/notifications#WebSocketChannel2023\",\n  \"topic\": \"http://localhost:3000/foo\"\n}\n</code></pre> <p>If you have <code>Read</code> permissions, the server's reply will look like this:</p> <pre><code>{\n  \"@context\": [ \"https://www.w3.org/ns/solid/notification/v1\" ],\n  \"id\": \"http://localhost:3000/.notifications/WebSocketChannel2023/dea6f614-08ab-4cc1-bbca-5dece0afb1e2\",\n  \"type\": \"http://www.w3.org/ns/solid/notifications#WebSocketChannel2023\",\n  \"topic\": \"http://localhost:3000/foo\",\n  \"receiveFrom\": \"ws://localhost:3000/.notifications/WebSocketChannel2023/?auth=http%3A%2F%2Flocalhost%3A3000%2F.notifications%2FWebSocketChannel2023%2Fdea6f614-08ab-4cc1-bbca-5dece0afb1e2\"\n}\n</code></pre> <p>The most important field is <code>receiveFrom</code>. This field tells you the WebSocket to which you need to connect, through which you will start receiving notifications. In JavaScript, this can be done using the WebSocket object, such as:</p> <pre><code>const ws = new WebSocket(receiveFrom);\nws.on('message', (notification) =&gt; console.log(notification));\n</code></pre>"},{"location":"usage/notifications/#webhooks","title":"Webhooks","text":"<p>Similar to the WebSocket subscription, below is sample JSON-LD that would be sent to <code>http://localhost:3000/.notifications/WebhookChannel2023/</code>:</p> <pre><code>{\n  \"@context\": [ \"https://www.w3.org/ns/solid/notification/v1\" ],\n  \"type\": \"http://www.w3.org/ns/solid/notifications#WebhookChannel2023\",\n  \"topic\": \"http://localhost:3000/foo\",\n  \"sendTo\": \"https://example.com/webhook\"\n}\n</code></pre> <p>Note that this document has an additional <code>sendTo</code> field. This is the Webhook URL of your server, the URL to which you want the notifications to be sent.</p> <p>The response would then be something like this:</p> <pre><code>{\n  \"@context\": [ \"https://www.w3.org/ns/solid/notification/v1\" ],\n  \"id\": \"http://localhost:3000/.notifications/WebhookChannel2023/eeaf2c17-699a-4e53-8355-e91d13807e5f\",\n  \"type\": \"http://www.w3.org/ns/solid/notifications#WebhookChannel2023\",\n  \"topic\": \"http://localhost:3000/foo\",\n  \"sendTo\": \"https://example.com/webhook\"\n}\n</code></pre>"},{"location":"usage/notifications/#streaming-http","title":"Streaming HTTP","text":"<p>Currently, Streaming HTTP channels are only available as pre-established channels on each resource. This means that subscribing and unsubscribing are not supported, and no subscription services are advertised. Instead, each resource advertises the <code>receiveFrom</code> of its pre-established notification channel using HTTP Link header, using <code>rel=\"http://www.w3.org/ns/solid/terms#updatesViaStreamingHttp2023\"</code>.</p> <p>For example, this \u2014</p> <pre><code>curl --head 'http://localhost:3000/foo/'\n</code></pre> <pre><code>HTTP/1.1 200 OK\nLink: &lt;http://localhost:3000/.notifications/StreamingHTTPChannel2023/foo/&gt;; rel=\"http://www.w3.org/ns/solid/terms#updatesViaStreamingHttp2023\"\n</code></pre> <p>It is essential to remember that any HTTP request to that <code>receiveFrom</code> endpoint requires the same authorization as a <code>GET</code> request on the resource which advertises it.</p> <p>Currently, all pre-established Streaming HTTP channels have <code>Content-Type: text/turtle</code>.</p> <p>Information on how to consume Streaming HTTP responses is available on MDN</p>"},{"location":"usage/notifications/#unsubscribing-from-a-notification-channel","title":"Unsubscribing from a notification channel","text":"<p>Note</p> <p>This feature is not part of the Solid Notification v0.2 specification so might be changed or removed in the future.</p> <p>If you no longer want to receive notifications on the channel you created, you can send a <code>DELETE</code> request to the channel to remove it. Use the value found in the <code>id</code> field of the subscription response. There is no way to retrieve this identifier later on, so make sure to keep track of it just in case you want to unsubscribe at some point. No authorization is needed for this request.</p>"},{"location":"usage/notifications/#notification-format","title":"Notification format","text":"<p>Below is an example notification that would be sent when a resource changes:</p> <pre><code>{\n  \"@context\": [\n    \"https://www.w3.org/ns/activitystreams\",\n    \"https://www.w3.org/ns/solid/notification/v1\"\n  ],\n  \"id\": \"urn:123456:http://example.com/foo\",\n  \"type\": \"Update\",\n  \"object\": \"http://localhost:3000/foo\",\n  \"state\": \"987654\",\n  \"published\": \"2023-02-09T15:08:12.345Z\"\n}\n</code></pre> <p>A notification contains the following fields:</p> <ul> <li><code>id</code>: A unique identifier for this notification.</li> <li><code>type</code>: What happened to trigger the notification. We discuss the possible values below.</li> <li><code>object</code>: The resource that changed.</li> <li><code>state</code>: An identifier indicating the state of the resource.   This corresponds to the <code>ETag</code> value you get when doing a request on the resource itself.</li> <li><code>published</code>: When this change occurred.</li> </ul>"},{"location":"usage/notifications/#notification-types","title":"Notification types","text":"<p>CSS supports five different notification types that the client can receive. The format of the notification can slightly change depending on the type.</p> <p>Resource notification types:</p> <ul> <li><code>Create</code>: When the resource is created.</li> <li><code>Update</code>: When the existing resource is changed.</li> <li><code>Delete</code>: When the resource is deleted. Does not have a <code>state</code> field.</li> </ul> <p>Additionally, when listening to a container, there are two extra notifications that are sent out when the contents of the container change. For these notifications, the <code>object</code> fields references the resource that was added or removed, while the new <code>target</code> field references the container itself.</p> <ul> <li><code>Add</code>: When a new resource is added to the container.</li> <li><code>Remove</code>: When a resource is removed from the container.</li> </ul>"},{"location":"usage/notifications/#features","title":"Features","text":"<p>The Solid notification specification describes several extra features that can be supported by notification channels. By default, these are all supported on the channels of a CSS instance, as can be seen in the descriptions returned by the server above. Each feature can be enabled by adding a field to the JSON-LD you send during subscription. The available fields are:</p> <ul> <li><code>startAt</code>: An <code>xsd:dateTime</code> describing when you want notifications to start.   No notifications will be sent on this channel before this time.</li> <li><code>endAt</code>: An <code>xsd:dateTime</code> describing when you want notifications to stop.   The channel will be destroyed at that time, and no more notifications will be sent.</li> <li><code>state</code>: A string corresponding to the <code>state</code> string of a resource notification.   If this value differs from the actual state of the resource,   a notification will be sent out immediately to inform the client that its stored state is outdated.</li> <li><code>rate</code>: An <code>xsd:duration</code> indicating how often notifications can be sent out.   A new notification will only be sent out after this much time has passed since the previous notification.</li> <li><code>accept</code>: A description of the <code>content-type(s)</code> in which the client would want to receive the notifications.   Expects the same values as an <code>Accept</code> HTTP header.</li> </ul>"},{"location":"usage/notifications/#important-note-for-server-owners","title":"Important note for server owners","text":"<p>There is not much restriction on who can create a new notification channel; only <code>Read</code> permissions on the target resource are required. It is therefore possible for the server to accumulate created channels. As these channels still get used every time their corresponding resource changes, this could degrade server performance.</p> <p>For this reason, the default server configuration removes notification channels after two weeks (20160 minutes). You can modify this behaviour by adding the following block to your configuration:</p> <pre><code>{\n  \"@id\": \"urn:solid-server:default:WebSocket2023Subscriber\",\n  \"@type\": \"NotificationSubscriber\",\n  \"maxDuration\": 20160\n}\n</code></pre> <p><code>maxDuration</code> defines after how many minutes every channel will be removed. Setting this value to 0 will allow channels to exist forever. Similarly, to change the maximum duration of webhook channels you can use the identifier <code>urn:solid-server:default:WebhookSubscriber</code>.</p>"},{"location":"usage/seeding-pods/","title":"How to seed Accounts and Pods","text":"<p>If you need to seed accounts and pods, the <code>--seedConfig</code> command line option can be used with as value the path to a JSON file containing configurations for every required pod. The file needs to contain an array of JSON objects, with each object containing at least an <code>email</code>, and <code>password</code> field. Multiple pod objects can also be assigned to such an object in the <code>pods</code> array to create pods for the account, with contents being the same as its corresponding JSON API.</p> <p>For example:</p> <pre><code>[\n  {\n    \"email\": \"hello@example.com\",\n    \"password\": \"abc123\"\n  },\n  {\n    \"email\": \"hello2@example.com\",\n    \"password\": \"123abc\",\n    \"pods\": [\n      { \"name\": \"pod1\" },\n      { \"name\": \"pod2\" }\n    ]\n  }\n]\n</code></pre> <p>This feature cannot be used to register pods with pre-existing WebIDs, which requires an interactive validation step, unless you disable the WebID ownership check in your server configuration.</p> <p>Note that pod seeding is made for a default server setup with standard email/password login. If you add a new login method you will need to create a new implementation of pod seeding if you want to use it.</p>"},{"location":"usage/starting-server/","title":"Starting the Community Solid Server","text":""},{"location":"usage/starting-server/#quickly-spinning-up-a-server","title":"Quickly spinning up a server","text":"<p>Use Node.js\u00a018.0 or up and execute:</p> <pre><code>npx @solid/community-server\n</code></pre> <p>Now visit your brand new server at http://localhost:3000/!</p> <p>To persist your pod's contents between restarts, use:</p> <pre><code>npx @solid/community-server -c @css:config/file.json -f data/\n</code></pre>"},{"location":"usage/starting-server/#local-installation","title":"Local installation","text":"<p>Install the npm package globally with:</p> <pre><code>npm install -g @solid/community-server\n</code></pre> <p>To run the server with in-memory storage, use:</p> <pre><code>community-solid-server # add parameters if needed\n</code></pre> <p>To run the server with your current folder as storage, use:</p> <pre><code>community-solid-server -c @css:config/file.json -f data/\n</code></pre>"},{"location":"usage/starting-server/#configuring-the-server","title":"Configuring the server","text":"<p>The Community Solid Server is designed to be flexible such that people can easily run different configurations. This is useful for customizing the server with plugins, testing applications in different setups, or developing new parts for the server without needing to change its base code.</p> <p>An easy way to customize the server is by passing parameters to the server command. These parameters give you direct access to some commonly used settings:</p> parameter name default value description <code>--port, -p</code> <code>3000</code> The TCP port on which the server should listen. <code>--baseUrl, -b</code> <code>http://localhost:$PORT/</code> The base URL used internally to generate URLs. Change this if your server does not run on <code>http://localhost:$PORT/</code>. <code>--socket</code> The Unix Domain Socket on which the server should listen. <code>--baseUrl</code> must be set if this option is provided <code>--loggingLevel, -l</code> <code>info</code> The detail level of logging; useful for debugging problems. Use <code>debug</code> for full information. <code>--config, -c</code> <code>@css:config/default.json</code> The configuration(s) for the server. The default only stores data in memory; to persist to your filesystem, use <code>@css:config/file.json</code> <code>--rootFilePath, -f</code> <code>./</code> Root folder where the server stores data, when using a file-based configuration. <code>--sparqlEndpoint, -s</code> URL of the SPARQL endpoint, when using a quadstore-based configuration. <code>--showStackTrace, -t</code> false Enables detailed logging on error output. <code>--podConfigJson</code> <code>./pod-config.json</code> Path to the file that keeps track of dynamic Pod configurations. Only relevant when using <code>@css:config/dynamic.json</code>. <code>--seedConfig</code> Path to the file that keeps track of seeded account configurations. <code>--mainModulePath, -m</code> Path from where Components.js will start its lookup when initializing configurations. <code>--workers, -w</code> <code>1</code> Run in multithreaded mode using workers. Special values are <code>-1</code> (scale to <code>num_cores-1</code>), <code>0</code> (scale to <code>num_cores</code>) and 1 (singlethreaded). <p>Parameters can also be passed through environment variables.</p> <p>They are prefixed with <code>CSS_</code> and converted from <code>camelCase</code> to <code>CAMEL_CASE</code></p> <p>eg. <code>--showStackTrace</code> =&gt; <code>CSS_SHOW_STACK_TRACE</code></p> <p>Command-line arguments will always override environment variables.</p>"},{"location":"usage/starting-server/#alternative-ways-to-run-the-server","title":"Alternative ways to run the server","text":""},{"location":"usage/starting-server/#from-source","title":"From source","text":"<p>If you rather prefer to run the latest source code version, or if you want to try a specific branch of the code, you can use:</p> <pre><code>git clone https://github.com/CommunitySolidServer/CommunitySolidServer.git\ncd CommunitySolidServer\nnpm ci\nnpm start -- # add parameters if needed\n</code></pre>"},{"location":"usage/starting-server/#via-docker","title":"Via Docker","text":"<p>Docker allows you to run the server without having Node.js installed. Images are built on each tagged version and hosted on Docker Hub.</p> <pre><code># Clone the repo to get access to the configs\ngit clone https://github.com/CommunitySolidServer/CommunitySolidServer.git\ncd CommunitySolidServer\n# Run the image, serving your `~/Solid` directory on `http://localhost:3000`\ndocker run --rm -v ~/Solid:/data -p 3000:3000 -it solidproject/community-server:latest\n# Or use one of the built-in configurations\ndocker run --rm -p 3000:3000 -it solidproject/community-server -c config/default.json\n# Or use your own configuration mapped to the right directory\ndocker run --rm -v ~/solid-config:/config -p 3000:3000 -it solidproject/community-server -c /config/my-config.json\n# Or use environment variables to configure your css instance\ndocker run --rm -v ~/Solid:/data -p 3000:3000 -it -e CSS_CONFIG=config/file-no-setup.json -e CSS_LOGGING_LEVEL=debug solidproject/community-server\n</code></pre>"},{"location":"usage/starting-server/#using-a-helm-chart","title":"Using a Helm Chart","text":"<p>The official Helm Chart for Kubernetes deployment is maintained at CommunitySolidServer/css-helm-chart and published on ArtifactHUB. There you will find complete installation instructions.</p> <pre><code># Summary\nhelm repo add community-solid-server https://communitysolidserver.github.io/css-helm-chart/charts/\nhelm install my-css community-solid-server/community-solid-server\n</code></pre>"},{"location":"usage/account/json-api/","title":"Account management JSON API","text":"<p>Everything related to account management is done through a JSON API, of which we will describe all paths below. There are also HTML pages available to handle account management that use these APIs internally. Links to these can be found in the HTML controls All APIs expect JSON as input, and will return JSON objects as output.</p>"},{"location":"usage/account/json-api/#finding-api-urls","title":"Finding API URLs","text":"<p>All URLs below are relative to the index account API URL, which by default is <code>http://localhost:3000/.account/</code>. Every response of an API request will contain a <code>controls</code> object, containing all the URLs of the other API endpoints. It is generally advised to make use of these controls instead of hardcoding the URLs. Only the initial index URL needs to be known then to find the controls. Certain controls will be missing if those features are disabled in the configuration.</p>"},{"location":"usage/account/json-api/#api-requests","title":"API requests","text":"<p>Many APIs require a POST request to perform an action. When doing a GET request on these APIs they will return an object describing what input is expected for the POST.</p>"},{"location":"usage/account/json-api/#authorization","title":"Authorization","text":"<p>After logging in, the API will return a <code>set-cookie</code> header of the format <code>css-account=$VALUE</code> This cookie is necessary to have access to many of the APIs. When including this cookie, the controls object will also be extended with new URLs that are now accessible. When logging in, the response body JSON body will also contain an <code>authorization</code> field containing the <code>$VALUE</code> value mentioned above. Instead of using cookies, this value can be used in an <code>Authorization</code> header with value <code>CSS-Account-Token $VALUE</code> to achieve the same result.</p> <p>The expiration time of this cookie will be refreshed every time there is a successful request to the server with that cookie.</p>"},{"location":"usage/account/json-api/#redirecting","title":"Redirecting","text":"<p>As redirects through status codes 3xx can make working with JSON APIs more difficult, the API will never make use of this. Instead, if a redirect is required after an action, the response JSON object will return a <code>location</code> field. This is the next URL that should be fetched. This is mostly relevant in OIDC interactions as these cause the interaction to progress.</p>"},{"location":"usage/account/json-api/#controls","title":"Controls","text":"<p>Below is an overview of all the keys in a controls object returned by the server, with all features enabled. An example of what such an object looks like can be found at the bottom of the page.</p>"},{"location":"usage/account/json-api/#controlsmain","title":"controls.main","text":"<p>General controls that require no authentication.</p>"},{"location":"usage/account/json-api/#controlsmainindex","title":"controls.main.index","text":"<p>General entrypoint to the API. Returns an empty object, including the controls, on all GET requests.</p>"},{"location":"usage/account/json-api/#controlsmainlogins","title":"controls.main.logins","text":"<p>Returns an overview of all login systems available on the server in <code>logins</code> object. Keys are a string description of the login system and values are links to their login pages. This can be used to let users choose how they want to log in. By default, the object only contains the email/password login system.</p>"},{"location":"usage/account/json-api/#controlsaccount","title":"controls.account","text":"<p>All controls related to account management. All of these require authorization, except for the create action.</p>"},{"location":"usage/account/json-api/#controlsaccountcreate","title":"controls.account.create","text":"<p>Creates a new account on empty POST requests. The response contains the necessary cookie values to log in. This account can not be used until a login method has been added to it. All other interactions will fail until this is the case. See the controls.password.create section below for more information on how to do this. This account will expire after some time if no login method is added.</p>"},{"location":"usage/account/json-api/#controlsaccountlogout","title":"controls.account.logout","text":"<p>Logs the account out on an empty POST request. Invalidates the cookie that was used.</p>"},{"location":"usage/account/json-api/#controlsaccountwebid","title":"controls.account.webId","text":"<p>GET requests return all WebIDs linked to this account in the following format:</p> <pre><code>{\n  \"webIdLinks\": {\n    \"http://localhost:3000/test/profile/card#me\": \"http://localhost:3000/.account/account/c63c9e6f-48f8-40d0-8fec-238da893a7f2/webid/fdfc48c1-fe6f-4ce7-9e9f-1dc47eff803d/\"\n  }\n}\n</code></pre> <p>The URL value is the resource URL corresponding to the link with this WebID. The link can be removed by sending a DELETE request to that URL.</p> <p>POST requests link a WebID to the account, allowing the account to identify as that WebID during an OIDC authentication interaction. Expected input is an object containing a <code>webId</code> field. The response will include the resource URL.</p> <p>If the chosen WebID is contained within a Solid pod created by this account, the request will succeed immediately. If not, an error will be thrown, asking the user to add a specific triple to the WebID to confirm that they are the owner. After this triple is added, a second request will be successful.</p>"},{"location":"usage/account/json-api/#controlsaccountpod","title":"controls.account.pod","text":"<p>GET requests return all pods created by this account in the following format:</p> <pre><code>{\n  \"pods\": {\n    \"http://localhost:3000/test/\": \"http://localhost:3000/.account/account/c63c9e6f-48f8-40d0-8fec-238da893a7f2/pod/df2d5a06-3ecd-4eaf-ac8f-b88a8579e100/\"\n  }\n}\n</code></pre> <p>The URL value is the resource URL corresponding to the link with this WebID. Doing a GET request to this resource will return the base URl of the pod, and all its owners of a pod, as shown below. You can send a POST request to this resource with a <code>webId</code> and <code>visible: boolean</code> field to add/update an owner and set its visibility. Visibility determines whether the owner is exposed through a link header when requesting the pod. You can also send a POST request to this resource with a <code>webId</code> and <code>remove: true</code> field to remove the owner.</p> <pre><code>{\n  \"baseUrl\": \"http://localhost:3000/my-pod/\",\n  \"owners\": [\n    {\n      \"webId\": \"http://localhost:3000/my-pod/profile/card#me\",\n      \"visible\": false\n    }\n  ]\n}\n</code></pre> <p>POST requests to <code>controls.account.pod</code> create a Solid pod for the account. The only required field is <code>name</code>, which will determine the name of the pod.</p> <p>Additionally, a <code>settings</code> object can be sent along, the values of which will be sent to the templates used when generating the pod. If this <code>settings</code> object contains a <code>webId</code> field, that WebID will be the WebID that has initial access to the pod.</p> <p>If no WebID value is provided, a WebID will be generated in the pod and immediately linked to the account as described in controls.account.webID. This WebID will then be the WebID that has initial access.</p>"},{"location":"usage/account/json-api/#controlsaccountclientcredentials","title":"controls.account.clientCredentials","text":"<p>GET requests return all client credentials created by this account in the following format:</p> <pre><code>{\n  \"clientCredentials\": {\n    \"token_562cdeb5-d4b2-4905-9e62-8969ac10daaa\": \"http://localhost:3000/.account/account/c63c9e6f-48f8-40d0-8fec-238da893a7f2/client-credentials/063ee3a7-e80f-4508-9f79-ffddda9df8d4/\"\n  }\n}\n</code></pre> <p>The URL value is the resource URL corresponding to that specific token. Sending a GET request to that URL will return information about the token, such as what the associated WebID is. The token can be removed by sending a DELETE request to that URL.</p> <p>Creates a client credentials token on POST requests. More information on these tokens can be found here. Expected input is an object containing a <code>name</code> and <code>webId</code> field. The name is optional and will be used to name the token, the WebID determines which WebID you will identify as when using that token. It needs to be a WebID linked to the account as described in controls.account.webID.</p>"},{"location":"usage/account/json-api/#controlspassword","title":"controls.password","text":"<p>Controls related to managing the email/password login method.</p>"},{"location":"usage/account/json-api/#controlspasswordcreate","title":"controls.password.create","text":"<p>GET requests return all email/password logins of this account in the following format:</p> <pre><code>{\n  \"passwordLogins\": {\n    \"test@example.com\": \"http://localhost:3000/.account/account/c63c9e6f-48f8-40d0-8fec-238da893a7f2/login/password/7f042779-e2b2-444d-8cd9-50bd9cfa516d/\"\n  }\n}\n</code></pre> <p>The URL value is the resource URL corresponding to the login with the given email address. The login can be removed by sending a DELETE request to that URL. The password can be updated by sending a POST request to that URL with the body containing an <code>oldPassword</code> and a <code>newPassword</code> field.</p> <p>POST requests create an email/password login and adds it to the account you are logged in as. Expects <code>email</code> and <code>password</code> fields.</p>"},{"location":"usage/account/json-api/#controlspasswordlogin","title":"controls.password.login","text":"<p>POST requests log a user in and return the relevant cookie values. Expected fields are <code>email</code>, <code>password</code>, and optionally a <code>remember</code> boolean. The <code>remember</code> value determines if the returned cookie is only valid for the session, or for a longer time.</p>"},{"location":"usage/account/json-api/#controlspasswordforgot","title":"controls.password.forgot","text":"<p>Can be used when a user forgets their password. POST requests with an <code>email</code> field will send an email with a link to reset the password.</p>"},{"location":"usage/account/json-api/#controlspasswordreset","title":"controls.password.reset","text":"<p>Used to handle reset password URLs generated when a user forgets their password. Expected input values for the POST request are <code>recordId</code>, which was generated when sending the reset mail, and <code>password</code> with the new password value.</p>"},{"location":"usage/account/json-api/#controlsoidc","title":"controls.oidc","text":"<p>These controls are related to completing OIDC interactions.</p>"},{"location":"usage/account/json-api/#controlsoidccancel","title":"controls.oidc.cancel","text":"<p>Sending a POST request to this API will cancel the OIDC interaction and return the user to the client that started the interaction.</p>"},{"location":"usage/account/json-api/#controlsoidcprompt","title":"controls.oidc.prompt","text":"<p>This API is used to determine what the next necessary step is in the OIDC interaction. The response will contain a <code>location</code> field, containing the URL to the next page the user should go to, and a <code>prompt</code> field, indicating the next step that is necessary to progress the OIDC interaction. The three possible prompts are the following:</p> <ul> <li>account: The user needs to log in, so they have an account cookie.</li> <li>login: The user needs to pick the WebID they want to use in the resulting OIDC token.</li> <li>consent: The user needs to consent to the interaction.</li> </ul>"},{"location":"usage/account/json-api/#controlsoidcwebid","title":"controls.oidc.webId","text":"<p>Relevant for solving the login prompt. GET request will return a list of WebIDs the user can choose from. This is the same result as requesting the account information and looking at the linked WebIDs. The POST requests expects a <code>webId</code> value and optionally a <code>remember</code> boolean. The latter determines if the server should remember the picked WebID for later interactions.</p>"},{"location":"usage/account/json-api/#controlsoidcforgetwebid","title":"controls.oidc.forgetWebId","text":"<p>POST requests to this API will cause the OIDC interaction to forget the picked WebID so a new one can be picked by the user.</p>"},{"location":"usage/account/json-api/#controlsoidcconsent","title":"controls.oidc.consent","text":"<p>A GET request to this API will return all the relevant information about the client doing the request. A POST requests causes the OIDC interaction to finish. It can have an optional <code>remember</code> value, which allows for refresh tokens if it is set to true.</p>"},{"location":"usage/account/json-api/#controlshtml","title":"controls.html","text":"<p>All these controls link to HTML pages and are thus mostly relevant to provide links to let the user navigate around. The most important one is probably <code>controls.html.account.account</code> which links to an overview page for the account.</p>"},{"location":"usage/account/json-api/#example","title":"Example","text":"<p>Below is an example of a controls object in a response.</p> <pre><code>{\n  \"main\": {\n    \"index\": \"http://localhost:3000/.account/\",\n    \"logins\": \"http://localhost:3000/.account/login/\"\n  },\n  \"account\": {\n    \"create\": \"http://localhost:3000/.account/account/\",\n    \"logout\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/logout/\",\n    \"webId\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/webid/\",\n    \"pod\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/pod/\",\n    \"clientCredentials\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/client-credentials/\"\n  },\n  \"password\": {\n    \"create\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/login/password/\",\n    \"login\": \"http://localhost:3000/.account/login/password/\",\n    \"forgot\": \"http://localhost:3000/.account/login/password/forgot/\",\n    \"reset\": \"http://localhost:3000/.account/login/password/reset/\"\n  },\n  \"oidc\": {\n    \"cancel\": \"http://localhost:3000/.account/oidc/cancel/\",\n    \"prompt\": \"http://localhost:3000/.account/oidc/prompt/\",\n    \"webId\": \"http://localhost:3000/.account/oidc/pick-webid/\",\n    \"forgetWebId\": \"http://localhost:3000/.account/oidc/forget-webid/\",\n    \"consent\": \"http://localhost:3000/.account/oidc/consent/\"\n  },\n  \"html\": {\n    \"main\": {\n      \"login\": \"http://localhost:3000/.account/login/\"\n    },\n    \"account\": {\n      \"createClientCredentials\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/client-credentials/\",\n      \"createPod\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/pod/\",\n      \"linkWebId\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/webid/\",\n      \"account\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/\"\n    },\n    \"password\": {\n      \"register\": \"http://localhost:3000/.account/login/password/register/\",\n      \"login\": \"http://localhost:3000/.account/login/password/\",\n      \"create\": \"http://localhost:3000/.account/account/ade5c046-e882-4b56-80f4-18cb16433360/login/password/\",\n      \"forgot\": \"http://localhost:3000/.account/login/password/forgot/\"\n    }\n  }\n}\n</code></pre>"},{"location":"usage/account/login-method/","title":"Adding a new login method","text":"<p>By default, the server allows users to use email/password combinations to identify as the owner of their account. But, just like with many other parts of the server, this can be extended so other login methods can be used. Here we'll cover everything that is necessary.</p>"},{"location":"usage/account/login-method/#components","title":"Components","text":"<p>These are the components that are needed for adding a new login method. Not all of these are mandatory, but they can make the life of the user easier when trying to find and use the new method. Also have a look at the general structure of new API components to see what is expected of such a component.</p>"},{"location":"usage/account/login-method/#create-component","title":"Create component","text":"<p>There needs to be one or more components that allow a user to create an instance of the new login method and assign it to their account. The <code>CreatePasswordHandler</code> can be used as an example. This does not necessarily have to happen in a single request, potentially multiple requests can be used if the user has to perform actions on an external site for example. The only thing that matters is that at the end there is a new entry in the account's <code>logins</code> object.</p> <p>When adding logins of your method a new key will need to be chosen to group these logins together. The email/password method uses <code>password</code> for example.</p> <p>A new storage will probably need to be created to storage relevant metadata about this login method entry. Below is an example of how the <code>PasswordStore</code> is created:</p> <pre><code>{\n  \"@id\": \"urn:solid-server:default:PasswordStore\",\n  \"@type\": \"BasePasswordStore\",\n  \"storage\": {\n    \"@id\": \"urn:solid-server:default:PasswordStorage\",\n    \"@type\": \"EncodingPathStorage\",\n    \"relativePath\": \"/accounts/logins/password/\",\n    \"source\": {\n      \"@id\": \"urn:solid-server:default:KeyValueStorage\"\n    }\n  }\n}\n</code></pre>"},{"location":"usage/account/login-method/#login-component","title":"Login component","text":"<p>After creating a login instance, a user needs to be able to log in using the new method. This can again be done with multiple API calls if necessary, but the final one needs to be one that handles the necessary actions such as creating a cookie and finishing the OIDC interaction if necessary. The <code>ResolveLoginHandler</code> can be extended to take care of most of this, the <code>PasswordLoginHandler</code> provides an example of this.</p>"},{"location":"usage/account/login-method/#additional-components","title":"Additional components","text":"<p>Besides creating a login instance and logging in, it is always possible to offer additional functionality specific to this login method. The email/password method, for example, also has components for password recovery and updating a password.</p>"},{"location":"usage/account/login-method/#html-pages","title":"HTML pages","text":"<p>To make the life easier for users, at the very least you probably want to make an HTML page which people can use to create an instance of your login method. Besides that you could also make a page where people can combine creating an account with creating a login instance. The <code>templates/identity</code> folder contains all the pages the server has by default, which can be used as inspiration.</p> <p>These pages need to be linked to the <code>urn:solid-server:default:HtmlViewHandler</code>. Below is an example of this:</p> <pre><code>{\n  \"@id\": \"urn:solid-server:default:HtmlViewHandler\",\n  \"@type\": \"HtmlViewHandler\",\n  \"templates\": [{\n    \"@id\": \"urn:solid-server:default:CreatePasswordHtml\",\n    \"@type\": \"HtmlViewEntry\",\n    \"filePath\": \"@css:templates/identity/password/create.html.ejs\",\n    \"route\": {\n      \"@id\": \"urn:solid-server:default:AccountPasswordRoute\"\n    }\n  }]\n}\n</code></pre>"},{"location":"usage/account/login-method/#updating-the-login-handler","title":"Updating the login handler","text":"<p>The <code>urn:solid-server:default:LoginHandler</code> returns a list of available login methods, which are used to offer users a choice of which login method they want to use on the default login page. If you want the new method to also be offered you will have to add similar Components.js configuration:</p> <pre><code>{\n  \"@id\": \"urn:solid-server:default:LoginHandler\",\n  \"@type\": \"ControlHandler\",\n  \"controls\": [\n    {\n      \"ControlHandler:_controls_key\": \"Email/password combination\",\n      \"ControlHandler:_controls_value\": {\n        \"@id\": \"urn:solid-server:default:LoginPasswordRoute\"\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"usage/account/login-method/#controls","title":"Controls","text":"<p>All new relevant API endpoints should be added to the controls object, otherwise there is no way for users to find out where to send their requests. Similarly, links to the HTML pages should also be in the controls, so they can be navigated to. Examples of how to do this can be found here.</p> <p>The default account overview page makes some assumptions about the controls when building the page. Specifically, it checks if <code>controls.html.&lt;LOGIN_METHOD&gt;.create</code> exists, if yes, it automatically creates a link on the page so users can create new login instances for their account.</p>"},{"location":"usage/account/migration/","title":"Migrating data from v6 to v7","text":"<p>Below is a description of the changes that are necessary to migration data from v6 to v7 of the server.</p>"},{"location":"usage/account/migration/#account-data","title":"Account data","text":"<p>The format of the \"Forgot passwords records was changed\", but seeing as those are not important and new ones can be created if necessary, these can just be removed when migrating. By default, these were located in the <code>.internal/forgot-password/</code> folder so this entire folder can be removed.</p> <p>For existing accounts, the data was stored in the following format and location. Additionally to the details below, the tail of all resource identifiers were base64 encoded.</p> <ul> <li>Account data<ul> <li>Storage location: <code>.internal/accounts/</code></li> <li>Resource identifiers: <code>\"account/\" + encodeURIComponent(email)</code></li> <li>Data format: <code>{ webId, email, password, verified }</code></li> </ul> </li> <li>Account settings<ul> <li>Storage location: <code>.internal/accounts/</code>, so same location as the account data</li> <li>Resource identifiers: <code>webId</code></li> <li>Data format: <code>{ useIdp, podBaseUrl?, clientCredentials? }</code><ul> <li><code>useIdp</code> indicates if the WebID is linked to the account for identification.</li> <li><code>podBaseUrl</code> is defined if the account was created with a pod.</li> <li><code>clientCredentials</code> is an array containing the labels of all client credentials tokens created by the account.</li> </ul> </li> </ul> </li> <li>Client credentials tokens<ul> <li>Storage location: <code>.internal/accounts/credentials/</code></li> <li>Resource identifiers: the token label</li> <li>Data format: <code>{ webId, secret }</code></li> </ul> </li> </ul> <p>The <code>V6MigrationInitializer</code> class is responsible for migrating from this format to the new one and does so by reading in the old data and creating new instances in the <code>IndexedStorage</code>. In case you have an instance that made impactful changes to how storage is handled that would be the class to investigate and replace. Password data can be reused as the algorithm there was not changed. Email addresses are now stored in lowercase, so these need to be converted during migration.</p>"},{"location":"usage/account/migration/#other-internal-data","title":"Other internal data","text":"<p>The format of all other internal data was changed in the same way:</p> <ul> <li>Keys are no longer base64 encoded.   This means that if there were any slashes in the keys these will now result in containers.   Keys are URL encoded when necessary to prevent issues with file names when using the file system.</li> <li>Keys where the part of the key after the last slash is longer than 150 characters will be hashed.</li> <li>All values will be wrapped in a JSON object with 2 keys:<ul> <li>key: Contains the original key. Relevant for when keys are hashed so the original key can be retrieved.</li> <li>payload: The original value.</li> </ul> </li> </ul> <p>All internal storage that is not account data as described in the previous section will be removed to prevent issues with outdated formats. This applies to the following stored data:</p> <ul> <li>The key used for signing OIDC tokens. A new one will be generated by the server.<ul> <li><code>.internal/idp/keys/</code></li> </ul> </li> <li>All OIDC related tokens/grants/sessions/etc. Users will have to authenticate again.<ul> <li><code>.internal/idp/adapter/</code></li> </ul> </li> <li>All notification subscriptions. Users will have to resubscribe.<ul> <li><code>.internal/notifications/</code></li> </ul> </li> <li>All setup values.<ul> <li>These actually need to be migrated as some are important to prevent issues, such as the <code>rootInitialized</code> key, which prevents initialized roots from being overwritten.</li> <li><code>.internal/setup/</code></li> </ul> </li> </ul>"}]}